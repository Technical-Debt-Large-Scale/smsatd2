(1, 'Architectural Technical Debt: A Grounded Theory')
Architectural technical debt in a software-intensive system is driven by design decisions about its structure, frameworks, technologies, languages, etc. Unlike code-level technical debt, which can be readily detected by static analysers, and can often be refactored with minimal efforts, architectural debt is hard to detect, and its remediation is wide-ranging, daunting, and often avoided. The objective of this study is to develop a better understanding of how software development organisations conceptualize their architectural debt, and how they deal with it, if at all. We used a grounded theory method, eliciting qualitative data from software architects and senior technical staff from a wide range of software development organizations. The result of the study, i.e., the theory emerging from the collected data, constitutes an encompassing conceptual theory of architectural debt, identifying and relating concepts such as symptoms, causes, consequences, and management strategies. By grounding the findings in empirical data, the theory provides researchers and practitioners with evidence of which crucial factors of architectural technical debt are experienced in industrial contexts.
critical1 = True

(4, 'A Semiautomatic Approach to Identify Architectural Technical Debt from Heterogeneous Artifacts')
Architectural Technical Debt (ATD) is a metaphor used to describe decisions taken by software architects to accomplish short-term goals but possibly negatively affecting the long-term health of the system. However, ATD doesn’t receive enough attention for the architect teams because it is hard to identify, to measure, to prioritize, and its value is related to long-term maintenance and evolution of a system. In this research, we propose a model-driven approach that focuses on building a binary classification model for ATD identification based on the information gathered from artifacts produced during architecture design. This model will allow software architects to support the managing of conscious and unconscious ATD in their software projects. This proposal focuses on TD at the architecture-level only without considering source code. The effectiveness of this proposal will be evaluated using case studies and expert interviews.
critical2 = True

(8, 'An overview and comparison of technical debt measurement tools')
There are numerous commercial tools and research prototypes that offer support for measuring technical debt. However, different tools adopt different terms, metrics, and ways to identify and measure technical debt. These tools offer diverse features, and their popularity / community support varies significantly. Therefore, (a) practitioners face difficulties when trying to select a tool matching their needs; and (b) the concept of technical debt and its role in software development is blurred. We attempt to clarify the situation by comparing the features and popularity of technical debt measurement tools, and analyzing the existing empirical evidence on their validity. Our findings can help practitioners to find the most suitable tool for their purposes, and researchers by highlighting the current tool shortcomings.
critical8 = False

(9, 'A systematic literature review on Technical Debt prioritization: Strategies, processes, factors, and tools')
Repaying all technical debt (TD) present in a system may be unfeasible, as there is typically a shortage in the resources allocated for TD repayment. Therefore, TD prioritization is essential to best allocate such resources to determine which TD items are to be repaid first and which items are to be delayed until later releases. This study conducts a systematic literature review (SLR) to identify and analyze the currently researched TD prioritization approaches. The employed search strategy strove to achieve high completeness through the identification of a quasi-gold standard set, which was used to establish a search string to automatically retrieve papers from select research databases. The application of selection criteria, along with forward and backward snowballing, identified 24 TD prioritization approaches. The analysis of the identified approaches revealed a scarcity of approaches that account for cost, value, and resources constraint and a lack of industry evaluation. Furthermore, this SLR unveils potential gaps in the current TD prioritization research, which future research may explore.
critical9 = False

(10, 'On the temporality of introducing code technical debt')
Code Technical Debt (TD) is intentionally or unintentionally created when developers introduce inefficiencies in the codebase. This can be attributed to various reasons such as heavy work-load, tight delivery schedule, unawareness of good practices, etc. To shed light into the context that leads to technical debt accumulation, in this paper we investigate: (a) the temporality of code technical debt introduction in new methods, i.e., whether the introduction of technical debt is stable across the lifespan of the project, or if its evolution presents spikes; and (b) the relation of technical debt introduction and the development team’s workload in a given period. To answer these questions, we perform a case study on twenty-seven Apache projects, and inspect the number of Technical Debt Items introduced in 6-month sliding temporal windows. The results of the study suggest that: (a) overall, the number of Technical Debt Items introduced through new code is a stable metric, although it presents some spikes; and (b) the number of commits performed is not strongly correlated to the number of introduced Technical Debt Items.
critical10 = False

(16, 'Methods for Identifying Architectural Debt: A Systematic Mapping Study')
Technical debt in general refers to suboptimal decisions the practitioners make during software development that achieve short-term goals at the expense of long-term quality concerns. Architecture technical debt is a subset of technical debt, when software practitioners make wrong or sub-optimal decisions related to the architecture of the software. Identifying such architecture technical debt plays a crucial role in software quality. In the last decade, there were several methods proposed to identify architecture debts in the literature.In this study, we conduct a systematic literature review of methods that identify architecture technical debt by inspecting 28 primary studies published from 2011 to 2020. Based on the outcomes of our review: (1) design rule space and traceability graphs are the dominant techniques; (2) despite the increase of automated techniques in identifying architecture debt, pure manual methods using expert opinion is still popular; (3) majority of the approaches use code/version history to mine archictural technical debt; (4) the field is getting increasingly more attraction in the last five years.
critical16 = True

(18, 'Skuld: a self-learning tool for impact-driven technical debt management')
As the development progresses, software projects tend to accumulate Technical Debt and become harder to maintain. Multiple tools exist with the mission to help practitioners to better manage Technical Debt. Despite this progress, there is a lack of tools providing actionable and self-learned suggestions to practitioners aimed at mitigating the impact of Technical Debt in real projects. We aim to create a data-driven, lightweight, and self-learning tool positioning highly impactful refactoring proposals on a Jira backlog. Bearing this goal in mind, the first two authors have founded a startup, called Skuld.ai, with the vision of becoming the go-to software renovation company. In this tool paper, we present the software architecture and demonstrate the main functionalities of our tool. It has been showcased to practitioners, receiving positive feedback. Currently, its release to the market is underway thanks to an industry-research institute collaboration with Fraunhofer IESE to incorporate self-learning technical debt capabilities.
critical18 = True

(20, 'Long-Term Evaluation of Technical Debt in Open-Source Software')
Background: A consistent body of research and practice have identified that technical debt provides valuable and actionable insight into the design and implementation deficiencies of complex software systems. Existing software tools enable characterizing and measuring the amount of technical debt at selective granularity levels; by providing a computational model, they enable stakeholders to measure and ultimately control this phenomenon. Aims: In this paper we aim to study the evolution and characteristics of technical debt in open-source software. For this, we carry out a longitudinal study that covers the entire development history of several complex applications. The goal is to improve our understanding of how the amount and composition of technical debt changes in evolving software. We also study how new technical debt is introduced in software, as well as identify how developers handle its accumulation over the long term. Method: We carried out our evaluation using three complex, open-source Java applications. All 110 released versions, covering more than 10 years of development history for each application were analyzed using SonarQube. We studied how the amount, composition and history of technical debt changed during development, compared our results across the studied applications and present our most important findings. Results: For each application, we identified key versions during which large amounts of technical debt were added, removed or both. This had significantly more impact when compared to the lines of code or class count increases that generally occurred during development. However, within each version, we found high correlation between file lines of code and technical debt. We observed that the Pareto principle was satisfied for the studied applications, as 20% of issue types generated around 80% of total technical debt. Interestingly, there was a large degree of overlap between the issues that generated most of the debt across the studied applications. Conclusions: Early application versions showed greater fluctuation in the amount of existing technical debt. We found application size to be an unreliable predictor for the quantity of technical debt. Most debt was introduced in applications as part of milestone releases that expanded their feature set; likewise, we identified releases where extensive refactoring significantly reduced the level of debt. We also discovered that technical debt issues persist for a long time in source code, and their removal did not appear to be prioritized according to type or severity.
critical20 = True

(21, 'The practitioners point of view on the concept of technical debt and its causes and consequences: a design for a global family of industrial surveys and its first …')
Context Studying the causes of technical debt (TD) could aid in TD prevention, thus easing the job of TD management. On the other hand, better understanding of the effects of TD could also aid in TD management by facilitating more informed decisions about incurring and paying off debt.Objective Create a deeper understanding, and confirming existing evidence, of the causes and effects of TD by collecting new evidence from real-world TD examples.Method InsighTD is a globally distributed family of industrial surveys on the causes and effects of TD. It is designed to run as a large-scale study based on continuous and independent replications in different countries. The survey instrument asks practitioners to describe in detail a real example of TD from their experience. We present in this paper the design of InsighTD, which has the primary goal of replication at a large-scale, with the results of the study in Brazil as a small part of the larger puzzle. ResultsThe first iteration of the InsighTD survey, carried out in Brazil, yielded 107 responses. We identified a total of 78 causes and 66 effects, which confirm and also extend the current knowledge on causes and effects of TD. Then, we organized the identified set of causes and effects in probabilistic cause-effect diagrams. The proposed diagrams highlight the causes that can most contribute to the occurrence of TD as well as the most common effects that occur as a result of debt. Conclusion We intend to reduce the problem of isolated TD investigations that are not yet representative and build a continuous and generalizable empirical basis for understanding practical problems and challenges of TD.
critical21 = False

(22, 'Developing a theory based on the causes of technical debt injection into software projects in Colombia')
Context Studying the causes of technical debt (TD) could aid in TD prevention, thus easing the job of TD management. On the other hand, better understanding of the effects of TD could also aid in TD management by facilitating more informed decisions about incurring and paying off debt.Objective Create a deeper understanding, and confirming existing evidence, of the causes and effects of TD by collecting new evidence from real-world TD examples.Method InsighTD is a globally distributed family of industrial surveys on the causes and effects of TD. It is designed to run as a large-scale study based on continuous and independent replications in different countries. The survey instrument asks practitioners to describe in detail a real example of TD from their experience. We present in this paper the design of InsighTD, which has the primary goal of replication at a large-scale, with the results of the study in Brazil as a small part of the larger puzzle. ResultsThe first iteration of the InsighTD survey, carried out in Brazil, yielded 107 responses. We identified a total of 78 causes and 66 effects, which confirm and also extend the current knowledge on causes and effects of TD. Then, we organized the identified set of causes and effects in probabilistic cause-effect diagrams. The proposed diagrams highlight the causes that can most contribute to the occurrence of TD as well as the most common effects that occur as a result of debt. Conclusion We intend to reduce the problem of isolated TD investigations that are not yet representative and build a continuous and generalizable empirical basis for understanding practical problems and challenges of TD.
critical22 = False

(24, 'Towards the Use of a Framework to Make Technical Debt Visible')
echnical debt concept has been in use since the 90s’s decade. Several processes, techniques and tools, such as those related with software maintenance and risk control, are used to manage, prevent, measure and reduce technical debt. Technical debt management includes activities to identify, measure, prioritize, repay, and monitor it, but one of the main issues related with management resides in the complexity to make technical debt visible to organizations. In this paper is presented the application of the Normative Process Framework to make technical debt visible with a large system developed by students of software engineering. The Normative Process Framework is used in conjunction with a process to find technical debt and document it in a simple format. Results show how technical debt was made visible for that system in a simplified way, by using documentation generated during development, and considering not only code, but also other software assets. Once technical debt is made visible is easier to evaluate and prioritize it, to establish a convenient set of actions to control it.
critical24 = False

(26, 'The Strategic Technical Debt Management Model: An Empirical Proposal')
Increasing development complexity in software applications raises major concerns about technical debt management, also in Open Source environments. A strategic management perspective provides organizations with an action map to pursue business’ targets with limited resources. This article presents the Strategic Technical Debt Management Model (STDMM) to provide practitioners with an actionable roadmap to manage their technical debt properly, considering both social and technical aspects. To do so, we pursued a theoretical mapping, exploiting a set of interviews of 124 carefully selected and well-informed domain experts of the IT financial sector.
critica26 = False

(31, 'Continuous Debt Valuation Approach (CoDVA) for Technical Debt Prioritization')
This paper proposes a technical debt prioritization technique to be used throughout software development lifecycle. Our method stresses a broader perspective of the product, so the focus is kept on optimizing the software artifacts supporting the complete flow of the value for the customer (including e.g. test environment or deployment pipelines). Many technical debt approaches are focused on static code analysis and misconsider business aspects as a separate activity. On the contrary, our method, based on the New Solution Selling Process, strongly advocates for a business perspective. It facilitates technical debt valuation against a predicted product roadmap by a close alignment with a structured sales process and the advancement of sales opportunities. Taking into account prediction of sales, progress of conversations with potential clients and bids, probability that a given functionality will be prioritized for the development, this approach may serve as a reference point for measuring business value of technical debt continuously. This valuation serves as a relative comparison of technical debt items enabling prioritization of effort to pay off technical debt. The method was evaluated on a release of a wireless telecommunication system. The results confirm that the suggested priorities may address the most profitable product areas from the company's perspective and ultimately optimize the value for customers.
critical31 = False

(33, 'On the diffuseness of technical debt items and accuracy of remediation time when using SonarQube')
Context. Among the static analysis tools available, SonarQube is one of the most used. SonarQube detects Technical Debt (TD) items—i.e., violations of coding rules—and then estimates TD as the time needed to remedy TD items. However, practitioners are still skeptical about the accuracy of remediation time estimated by the tool. Objective. In this paper, we analyze both diffuseness of TD items and accuracy of remediation time, estimated by SonarQube, to fix TD items on a set of 21 open-source Java projects. Method. We designed and conducted a case study where we asked 81 junior developers to fix TD items and reduce the TD of 21 projects. Results. We observed that TD items are diffused in the analyzed projects and most items are code smells. Moreover, the results point out that the remediation time estimated by SonarQube is inaccurate and, as compared to the actual time spent to fix TD items, is in most cases overestimated. Conclusions. The results of our study are promising for practitioners and researchers. The former can make more aware decisions during project execution and resource management, the latter can use this study as a starting point for improving TD estimation models.
critical33 = False

(37, 'Classification of Technical Debts in Software Development Using Text Analytics')
Technical debt refers to the technical trade-offs made by the software teams at the time of development of the software to fasten the delivery process. These trade-offs lead to a higher system maintenance cost, and it is difficult to often enhance the application. In some cases, enhancements can result in the entire modules being rewritten. So, in order to reduce the debt from the system, it is required to identify the debt and the project cycle where most of the debts occur. To automatically address this problem, this work uses the machine learning and text analytics model. Random forest and support vector machine (SVM) algorithms extract features from incident tracker documents and effectively classify the technical debts. The proposed technical debt classification model is made sustainable to handle the growing volumes of project documents by executing a distributed framework. The performance of both the models is examined, and it is found that SVM outperforms the other.
critical37 = False

(38, 'Experiences with technical debt and management strategies in production systems engineering')
Technical Debt (TD) has proven to be a suitable communication concept for software-intensive contexts to raise awareness regarding longterm negative effects of deviations from standards and guidelines. TD has also been introduced to systems engineering domain, to communicate design shortcomings in long-running, software-assisted systems. We analysed potential TD in the engineering data exchange for production system engineering. Similar to requirements engineering in software-intensive systems, data exchange in the design phase plays an integral part in Software Engineering (SE) for Production Systems Engineering: Specifications, and physical logic have to be derived from heterogeneous plant models or parameter tables designed by different stakeholders. However, traditional procedures and inadequate tool support lead to inefficient data extraction and integration. We identified debt arising from knowledge representation, data model and the exchange process. The refinement validation of identified TD was achieved through semi-structured interviews with representatives in two analysed companies. In an online survey with ten participants from an industrial consortium we evaluated whether the identified TD concepts also applied to other companies, which is true for the majority of TD. Furthermore, we discuss promising TD management strategies to repay and manage negative effects and the accumulation of additional debt, such as improved communication, test-driven model engineering and visualisation of engineering models.
critical38 = False

(39, 'Self-Admitted Technical Debt classification using LSTM neural network')
Context: In software development, new functionalities and bug fixes are required to ensure a better user experience. Sometimes developers need to implement quick changes to meet deadlines rather than a better solution that would take longer. These easy choices, known as Technical Debts, can cause long-term negative impacts because they can bring extra effort to the team in the future. One way to detect technical debts is through source code comments. Developers often insert comments in which they admit that there is a need to improve that part of the code later. This is known as Self-Admitted Technical Debt (SATD). Objective: Evaluate a Long short-term memory (LSTM) neural network model to identify design and requirement SATDs from comments in source code. Method: We performed a controlled experiment to evaluate the quality of the model compared with two language models from literature in a labeled dataset. Results: Our model results outperformed the other models in precision, improving average precision in approximately 8% compared to auto-sklearn and 19% compared to maximum entropy approach, however, the LSTM model achieved worse results in recall and f-measure. Conclusion: We found that the LSTM model can classify with better precision but needs a larger training, so it can improve on the detection of negative cases.
critical39 = True

(41, 'Towards an Approach to Identify Obsolete Features based on Importance and Technical Debt')
Many of today's software systems are maintained over years or even decades. To ensure that software remains useful, new features have to be added or old features have to be adapted to respond to new or changed requirements. As time goes on, some of the features become obsolete, i.e., are not needed anymore. Typically, these features are not removed because of various reasons, e.g., because removing them might be considered too costly, the costs of keeping unused features is considered low, or because of the 'sunk cost fallacy', i.e., that a feature is considered worth to keep because of the previously invested resources (time, money or effort) to build it. The consequences of keeping unused source code can impact maintainability, technical debt, performance, and extensibility of the system. This can lead to lower development productivity and to a reduced innovation ability, consequently reducing competitiveness on the market. This paper aims to present an approach to identify features based on their value and on costs for keeping or removing them.
critical41 = True

(43, 'A Quest for Indicators of Security Debt')
Security Debt (SD) manifests itself every day: In the media, we can witness stories about debt defaults: significant data leaks, disruptions of service, and businesses of global companies affected by security incidents. Critical infrastructure customers need more practical tools to ensure that the SD is properly identified in order to make informed risk decisions. Existing tools like security audits and cross-referencing system configuration with available vulnerability information do reveal a lot of data regarding the present state of the system. Many tools that can bring up the hidden security issues like ones included in Secure Development Lifecycles (SDLC) are tuned for the product creation. Some of them can be taken into good use by the customer, but for that, the system should be already procured and in place. In practice, the customer would benefit from a comprehensive and realistic view of the security stance of the system when it is being procured to minimize the nasty surprises the underlying security issues are prone to bring.
critical43 = True

(44, 'Improving agility by managing shared libraries in microservices')
Using microservices is a way of supporting an agile architecture. However, if the microservices development is not properly managed, the teams’ development velocity may be affected, reducing agility and increasing architectural technical debt. This paper investigates how to manage the use of shared libraries in microservices to improve agility during development. We interviewed practitioners from four large international companies involved in microservices projects to identify problems when using shared libraries. Our results show that the participating companies had issues with shared libraries as follows: coupling among teams, delays on fixes due to overhead on libraries development teams, and need to maintain many versions of the libraries. Our results highlight that the use of shared libraries may hinder agility on microservices. Thus, their use should be restricted to situations where shared libraries cannot be replaced by a microservice and the costs of replicating the code on each service is very high.
critial44 = True

(46, 'Managing security debt across PLC phases in a VSE context')
With the adoption of microservices architectural styles, practitioners started noticing increasing pitfalls in managing and maintaining such architectures, with the risk of introducing architectural debt. Previous studies identified different microservice smells (also named anti-patterns) that harm microservices architectures. However, according to our knowledge, there are no tools that can automatically detect microservice smells, so their identification is left to the experience of the developer. In this paper, we extend an existing tool developed for the detection of architectural smells to explore microservices architecture through the detection of three microservice smells: Cyclic Dependencies, Hard-Coded Endpoints, and Shared Persistence. We detected the smells on five open-source projects implemented with microservices and manually validated the precision of the detection results. This work aims to open new perspectives on facing and studying architectural debt in the field of microservices architectures.
critical46 = True

(48, 'A modeling method for systematic architecture reconstruction of microservice-based software systems')
Microservice Architecture (MSA) is an approach to architecting service-based software systems, which aims for decreasing service coupling to enable independent service development and deployment. Consequently, the adoption of MSA is expected to particularly benefit the scalability, maintainability, and reliability of monolithic systems. However, MSA adoption also increases architectural complexity in service design, implementation, and operation. As a result, Software Architecture Reconstruction (SAR) of microservice architectures is aggravated. This paper presents a modeling method that systematizes SAR of microservice architectures with the goal to facilitate its execution. The method yields reconstruction models for certain architecture viewpoints in MSA to enable efficient architecture analysis. We validate the method’s applicability by means of a case study architecture and the assessment of its risk in technical debt using derived reconstruction models.
critical48 = True

(50, 'Software Architecture Reconstruction via a Genetic Algorithm: Applying the Move Class Refactoring')
Modularity is one of the four key principles of software design and architecture. According to this principle, software should be organized into modules that are tightly linked internally (high cohesion), whereas at the same time as independent from other modules as possible (low coupling). However, in practice, this principle is violated due to poor architecting design decisions, lack of time, or coding shortcuts, leading to a phenomenon termed as architectural technical debt (ATD). To alleviate this problem (lack of architectural modularity), the most common solution is the application of a software refactoring, namely Move Class—i.e., moving classes (the core artifact in object-oriented systems) from one module to another. To identify Move Class refactoring opportunities, we employ a search-based optimization process, relying on optimization metrics, through which optimal moves are derived. Given the extensive search space required for applying a brute-force search strategy, in this paper, we propose the use of a genetic algorithm that re-arranges existing software classes into existing or new modules (software packages in Java, or folders in C++). To validate the usefulness of the proposed refactorings, we performed an industrial case study on three projects (from the Aviation, Healthcare, and Manufacturing application domains). The results of the study indicate that the proposed architecture reconstruction is able to improve modularity, improving both coupling and cohesion. The obtained results can be useful to practitioners through an open source tool; whereas at the same point, they open interesting future work directions.
critical50 = True

(54, 'Characterizing Architectural Drifts of Adaptive Systems')
An adaptive system (AS) evaluates its own behavior and changes it when the evaluation indicates that the system is not accomplishing what it is intended to do, or when better functionality or performance is possible. MAPE-K is a reference model that prescribes the adaptation mechanism of ASs by means of high-level abstractions such as Monitors, Analyzers, Planners and Executors and the relationships among them. Since the abstractions and the relationships provided by MAPE-K are generic, other reference models were proposed focusing on providing lower level abstractions to support software engineers in a more suitable way. However, after the analysis of seven representative ASs, we realized the abstractions prescribed by the existing reference models are not properly implemented, thus leading to architectural drifts. Therefore, in this paper we characterized three of these drifts by describing them with a template and showing practical examples. The three architectural drifts of ASs are Scattered Reference Inputs, Mixed Executors and Effectors, and Obscure Alternatives. We expect that by identifying and characterizing these drifts, we can help software architects improve their design and, as a consequence, increase the reliability of this type of systems.
critical54 = True

(55, 'Managing software evolution in embedded automotive systems')
Customer requirements evolve frequently in the automotive domain. A the same time, rapid integration of innovative solutions is important to maintain and extend the customer base (Vitale et al. 2020). Thus, automotive software components are subject to constant change and variations, even when the vehicle is already on the road (Guissouma et al. 2018).
critical55 = False

(56, 'A preliminary analysis of self-adaptive systems according to different issues')
Self-adaptive systems dynamically change their structure and behavior in response to changes in their execution environment to ensure the quality of the services they provide. Self-adaptive systems are usually built of a managed part, which implements their func- tionality, and a managing part, which implements the self-adaptive mechanisms. Hence, the complexity of self-adaptive systems results also from the existence of the managing part and the interaction between the managed and the managing parts. The available evalua- tion approaches of self-adaptive systems focus on their performances, i.e., on the benefits (e.g., degree of autonomy, support for detecting anomalous behavior, adaptivity time, qual- ity of response) achieved through the self-adaptive mechanisms of the managing part. In this paper, we evaluate the quality of the design of self-adaptive systems (including the managed and the managing parts) as it is done in traditional software engineering. We are interested in the internal software quality of self-adaptive systems, as the existence of the managing part and its interaction with the managed part leads to a tightly coupled system. We analyze the self-adaptive systems through the detection of different issues such as architectural and code smells and the detection of design patterns. The smells provide some hints on possible design and implementation problems, and help software engineers to improve the quality of the systems. While, design patterns are usually indicators of the application of good prac- tices in the software development and allow to capture part of the design rationale. In this way, they can help software engineers to understand, reuse, and extend self-adaptive sys- tems. In this paper, we have considered the detection of 3 architectural smells, 18 code smells, and 15 design patterns in 11 self-adaptive systems written in the Java programming language. The results indicate that the 3 architectural smells, 9 out of the 18 code smells, and the 15 design patterns have been detected in all the analyzed self-adaptive systems. We also discuss the possible reasons behind the presence of these quality issues, and provide our lessons learned.
critical56 = True

(58, 'An empirical investigation on the relationship between design and architecture smells')
Architecture of a software system represents the key design decisions and therefore its quality plays an important role to keep the software maintainable. Code smells are indicators of quality issues in a software system and are classified based on their granularity, scope, and impact. Despite a plethora of existing work on smells, a detailed exploration of architecture smells, their characteristics, and their relationships with smells in other granularities is missing.
critical58 = True