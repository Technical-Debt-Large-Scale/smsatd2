Paper Id;Citation;Google Scholar;Year;Authors;Title;Publication Year;Abstract;Venue Type;Venue;Name of Venue;Field;Key words;Number of Pages;Main aim (Goal);Dataset (Yes/No);Industry (Yes/No);Open Source Project (Yes/No);Real Data (Yes/No);Method of research (Case study, Survey, Interview, Experiment, Observation);Method of reasearch (detailed);Q7 Research Type (Evaluation Research, Validation Research, Solution Proposal, Philosophycal paper, Other);Q1 Type of ATD (Based on Li et al 2015);Q2(Measure);Q3(Monitoring);Q4(Techniques and tools);Q5(calculate the cost);Q6(How ATD is management?);Strong Aspects;Weak Aspects;Process Rigor;General relevance;Limitations;Future Works;Read
1;Perez et al. 2019;4;2019;Boris Perez, Dario Correal, Hernan Astudillo;"A Proposed Model-driven Approach to Manage Architectural Technical Debt Life Cycle 
";2019;Architectural Technical Debt (ATD) is a metaphor used to describe consciously decisions taken by software architects to accomplish short-term goals but possibly negatively affecting the long-term health of the system. However, difficulties arise when repayment strategies are defined because software architects need to be aware of the consequences of these strategies over others decisions in the software architecture. This article proposes REBEL, a semi-automated model-driven approach that exploits natural language processing, machine learning and model checking techniques on heterogeneous project artifacts to build a model that allows to locate and visualize the impact produced by the consciously injected ATD and its repayment strategy on the other architectural decisions. The technique is illustrated with a data analytics project in Colombia where software architects are unaware of the consequences of the repayment strategies. This proposal seeks to support teams of architects to make explicit the current and future impact of the ATD injected as a result of decisions taken, focusing on the architectural level rather than code level. ;Conference;2019 IEEE/ACM International Conference on Technical Debt (TechDebt);International Conference on Technical Debt (TechDebt);Technical Debt;"Architectural technical debt, Software architecture, Architectural technical debt management,  Model-driven architecture ";5;This article proposes REBEL (a semi-automated model-driven approach to manage aRchitectural tEchnical deBt (ATD)’s lifE cycLe. ), a semi-automated model-driven approach that exploits natural language processing, machine learning and model checking techniques on heterogeneous project artifacts to build a model that allows to locate and visualize the impact produced by the consciously injected ATD and its repayment strategy on the other architectural decisions. This proposal focus on ATD at architectural-level only without considering source code.;Yes;Yes;No;Yes;Case study, expert opinion, observation;"Case study in project Center of Excellence and Appropriation in Big Data and Data Analytics (CAOBA) in a joint collaboration among several universities in Colombia and the Tax Office in Bogota. software architecture documentation
";Evaluation research;Not specified;REBEL focuses on finding ATD items at architecture level only (documents), measuring the impact of its repayment strategy based on architecture decisions and allowing the debt to be anticipated or corrected before the implementation process begins.;The method performed a monitoring process for each release planning evaluated during the case study.;"general:""Model-Driven Architecture Approach, Natural Language Processing, Machine Learning, Heterogeneous artefacts""
# 
approuch:""REBEL focuses on finding ATD items at architecture level only, measuring the impact of its repayment strategy based on architecture decisions and allowing the debt to be anticipated or corrected before the implementation process begins
#
tools:""Rebel""";Yes. The amount of architectural decisions impacted by the ATD item is 3. This way, Impact = 3 * 5 * (3*3) = 135. If our ATD repayment strategy would not affect other decisions, the Impact would be I = 3 * 1 * (1*3) = 9. From these results, software architect understand the impact of a repayment strategy.;;The authors propose an approuch to identify ATD using documents and models without to get access to source code of the software.;There is no calculation formula about cost of ATD in terms of time or money to fix the ATD item identified.;problem characterization: yes, bibliographic review: yes, data collection: yes, hypothesis: no, experimentation: yes, results: yes, final: good;good. due to the authors propose an approuch to identify ATD wihout static code analysis. ;In this research we faced several challenges that became evident in the case study. First, much of the software architec- ture decisions were not fully documented. Client does not pay for documentation. Rationale of decisions is divided among several artifacts. In this case study we found that Slack was used to justify some decisions. Also, we found that several diagrams were made using PowerPoint. Another challenge we faced was the recovery process of these sources. One of the authors is part of the project so it was easy to have access to this information, but other projects couldn’t have its information so accessible. Also, more complex projects will require more artifacts to analyze and this will include different storing structures.;Future work will include convolutional neural networks to train a model to understand diagrams made in PowerPoint or another tool and saved as an image, such as IMEAV [19]. We also plan to include a recommendation system to suggests repayment strategies under certain conditions. Different meta- models for storing ATD should be reviewed. Finally, we will also look into including automatic text extraction methods for audio/video recordings to reduce human interaction.;Complete
2;Martini et al 2017;13;2017;Antonio Martini, Erik Sikander, Niel Madlani;A semi-automated framework for the identification and estimation of Architectural Technical Debt: A comparative case-study on the modularization of a software component ;2017;"Context: Research and industry’s attention has been focusing on developing systems that enable fast time to market in the short term, but would assure a sustainable delivery of business value and maintenance operations in the long run. A related phenomenon has been identified in Architectural Technical Debt: if the system architecture is sub-optimal for long-term business goals, it might need to be refactored. A key property of the system assuring long-term goals is its modularity, or else the degree to which components are decoupled: such property allows the product to be evolved without costly changes pervading the whole system. However, understanding the business benefits of refactoring to achieve modularity is not trivial, especially for large refactorings involving substantial architectural changes. 
Objective: The aim of this study was to develop a technique to identify Architectural Technical Debt in the form of a non-modularized component and to quantify the convenience of its repayment. Method: We have conducted a single, embedded case study in a large company, comparing a component before and after it was refactored to achieve modularity. We have developed a holistic framework for the semi-automated identification and estimation of Architectural Technical Debt in the form of non-modularized components. We then evaluate the technique reporting a comparative study of the difference in maintenance and development costs in two coexisting systems, one including the refactored component and one including the non-refactored one. 
Results: The main contributions are a measurement system for the identification of the Architectural Technical Debt according to the stakeholders’ goals, a mathematical relationship for calculating and quantifying its interest in terms of extra-effort spent in additional development and maintenance, and an overall decision framework to assess the benefit of refactoring. We also report context-specific results that show the estimated benefits of refactoring the specific case of Architectural Technical Debt. Conclusion: We found that it is possible to identify this kind of Architectural Technical Debt and to quantify its repayment convenience. Thanks to the developed framework, it was possible to estimate that the Architectural Technical Debt present in the component was causing substantial continuous extra- effort, and that the modularization would be repaid in several months of development and maintenance. ";Journal;Jornal Information and Software Technology;Jornal Information and Software Technology;Software Technology;"Measurement System, Software management, Refactoring , Estimation, Technical Debt, Modularization, Software Architecture ";16;"The aim of this study was to develop a technique to identify Architectural Technical Debt in the form of a non-modularized component and to quantify the convenience of its repayment

The identification of ATD is therefore one of the main activities of software architects. In this paper, we seek to develop an automated solution that would support the identification of a specific ATD kind. 

The goal of this paper is therefore to develop a technique to estimate the convenience of refactoring the ATD. 

The main contributions are a measurement system for the identification of the Architectural Technical Debt according to the stakeholders’ goals, a mathematical relationship for calculating and quantifying its interest in terms of extra-effort spent in additional development and maintenance, and an overall decision framework to assess the benefit of refactoring. We also report context-specific results that show the estimated benefits of refactoring the specific case of Architectural Technical Debt. 

RQ – How can we identify and estimate, in a quantitative way, if a non-modularized component is worth refactoring? 
RQ1 – How can we identify if a component contains ATD in the form of lack of modularization? 
RQ2 – How can we estimate the current extra-cost paid as interest of the ATD? 
RQ3 – How can we estimate the long-term cost saved by modularizing the component? 
";Yes;Yes;No;Yes;Case study, expert opinion;Embedded case study in a large company;Evaluation research;Complex architectural behavioral dependencies;Complexity measures of files;The framework performed a monitoring process for each release version evaluated during the case study.;"general:""specialist technical evaluation, modularity, measurement system, complexity, cohesion, coupling, code churn, source code, revision history""
# 
approuch:""own technique to identify, measure and calculate the ATD""
#
tools:""proprietary tool""";Developer Work Months (DWM). DWM is defined in this study as the amount of effort one developer generates each month.  Man-hours;;The authors proposed a semi-automated method to identify and calculate the cost of ATD in terms of estimated hours to fix the ATD item.;It is necessary an expert evaluation to estimate the effort to fix the ATD item. Besides, the authors did not talk about the future work.;"problem characterization: yes, bibliographic review: yes, data collection: yes, hypothesis: no, experimentation: yes, results: yes, final: good,extra:
This paper used quantitative and qualitative research to evaluate the proposed framework. ";"Great.The paper provides a way to identify and estimate ATD effort in hours using the modularity of components
 ";"To estimate the effort to fix the ATD is necessary, an evaluation of developers. So, it is necessary for a manual process to evaluate the efort.
";No;Complete
3;Roveda et al. 2018;13;2018;Riccardo Roveda, Francesca Arcelli Fontana, Ilaria Pigazzini, Marco Zanoni ;Towards an Architectural Debt Index;2018;Different indexes have been proposed to evaluate software quality and technical debt. Usually these indexes take into account different code level issues and several metrics, well known software metrics or new ones defined ad hoc for a specific purpose. In this paper we propose and define a new index, more oriented to the evaluation of architectural violations. We describe in detail the index, called Architectural Debt Index, that we integrated in a tool developed for architectural smell detection. The index is based on the detection of architectural smells, their criticality and their history. Currently only dependency architectural smells have been considered, but other architectural debt indicators can be considered and integrated in the index computation. ;Conference;Euromicro Conference on Software Engineering and Advanced Applications;Euromicro Conference on Software Engineering and Advanced Applications;Software Engineering and Advanced Applications;architectural smells, architectural debt index, severity index, technical debt ;9;"In this paper we propose and define a new index, more oriented to the evaluation of architectural violations. We describe in detail the index, called Architectural Debt Index, that we integrated in a tool developed for architectural smell detection. The index is based on the detection of architectural smells, their criticality and their history. 

The aim of our index is to evaluate the internal quality of a project in terms of: 1) the detected architectural smells, 
2) their history, 
3) their severity (the most critical ones) and 
4) architecture design metrics. The index value of a project with a large number of smells and also critical smells (high severity) will be higher with respect to a project with less smells and low severity. 

Hence in this work, we aim to answer the following research questions:
RQ1 How should a new index be formulated to more exhaustively evaluate architectural debt?

RQ2 How can we estimate the severity of an architectural smell?

RQ3 Is the new index based on architectural smell detection independent from another existing index based on code level issues?

";Yes;No;Yes;Yes;survey;"It was computed 109 open source projects from Qualitas Corpus We evaluated the ADI also according to these categories and the size of the projects in terms of number of packages.  ";Validation Research;Architecture Smells;It was defined a formula to calculate ATD index and Architectural Smell Impact Score.;The method performed a monitoring for each version analysed during the study.;"general:""architecture smells, modularity""
# 
approuch:""Unstable Dependency, Hub-Like Dependency, Cyclic Dependency, Implicit Cross Package Dependency,  ""
#
tools:""Arcan, SonarQube, Apache Commons BCEL, hellow2morrow""";No;;The authors defined a set of formulas to represent Architectural Debt Index using java open source projects to validate the ATDI proposed comparing with other TDI like sonarqube.;The data validation should be performed in a real industrial project. ;"problem characterization: yes, bibliographic review: yes, data collection: yes, hypothesis: no, experimentation: yes, results: yes, final: good,extra:The authors cited good references, tools, and important related works about Technical Debt Index. A particular highlight to SonarQube. 
It was defined as a set of groups of Architectural Smell detection using Arcan Tool.

The authors defined a set of formulas to represent Architectural Debt Index.

The authors shown a statistical analysis of the Architectural Debt Index proposed comparing with Qualitas Corpos.

The authors have detailed a good research design.";Good. the authors defined a set of formulas to represent Architectural Debt Index.;The data validation should be performed in a real industrial project. Besides there is calculus about cost or effort to fix the ATD items.;"The authors would also like to detect different categories of AS (architectural smells) that could impact different quality attributes, such as performance and security. in this direction, we could identify and compute different ADI index profiles according to the AS's impact on specific quality attributes.
Moreover, the authors aim to extend the index or define a new one to consider also the cost to remove the architectural smells ( cost- solving). This could allow developers/maintainers to make a business case (costs vs benefits) and help them to set the order in which they want to remove the AS. Towards the definition of this index oriented to the evaluation of the cost-solving, we are also interested to work on the development of some kind of automatic/semiautomatic refactoring support by studying the different refactoring opportunities of each AS. ";Complete
4;Snipes et al. 2018;1;2018;Will Snipes, Sunil L Karlekar, Ran Mo;A Case Study of the Effects of Architecture Debt on Software Evolution Effort ;2018;In large-scale software systems, the majority of defective files are architecturally connected, and the architecture connections usually exhibit design flaws, which are associated with higher change-proneness among files and higher mainte- nance costs. As software evolves with bug fixes, new features, or improvements, unresolved architecture design flaws can con- tribute to maintenance difficulties. The impact on effort due to architecture design flaws has been difficult to quantify and justify. In this paper, we conducted a case study where we identified flawed architecture relations and quantified their effects on maintenance activities. Using data from this project’s source code and revision history, we identified file groups where files are architecturally connected and participated in flawed architecture designs, quantified the maintenance activities in the detected files, and assessed the penalty related to these files ;Conference;Euromicro Conference on Software Engineering and Advanced Applications;Euromicro Conference on Software Engineering and Advanced Applications;Software engineering;Software Architecture, Software Maintenance, Technical Debt ;4;"we conducted a case study where we identified flawed architecture relations and quantified their effects on maintenance activities. Using data from this project’s source code and revision history, we identified file groups where files are architecturally connected and participated in flawed architecture designs, quantified the maintenance activities in the detected files, and assessed the penalty related to these files. 

The objective of this case study is to understand if the detected architecture debt have a continuous impact on software evolution. That is, as software evolves with new change requests, determine whether files associated with poor architecture design are still change-prone and have high maintenance costs. 

RQ1: Are the files involved in an architecture root still change-prone during software evolution? 
RQ2: Whether and to what extent the file groups identified in architecture roots are associated with higher maintenance effort? 

";Yes;Yes;No;Yes;case study;we present a case study on a large-scale project (in C#), which has evolved for 9 months through a series of change requests since the last release. In this case study, we used the definition and techniques to identify file groups where the files are architecturally connected and flawed by architecture issues .;Evaluation research;Complex architectural behavioral dependencies;Architectural Root;The case study performed a set of evaluations of revision history during the study.;"general:""architectural root, source code, revision history, Design Structure Matrix, code churn, change frequency, architectural smells, modularity""
 # 
 approuch:""Unstable Interface, Implicit Cross-module Dependency, Unhealthy Inheritance Hierarchy, Clique, Package cicle""
 #
 tools:""ArchDia""";The method proposed can calculate the expected effort spent on the amount of files in detected architecture roots during the analysed cycle in X staff-days to fix the ATD items identified. ;;The paper shows 5 (five) types of architecture issued detected in the case study: Unstable Interface, Implicit Cross-module dependency, Unhealth inheritance Hierarchy, clique and Package cycle.;It was not shared the data collection.;"problem characterization: yes, bibliographic review: yes, data collection: yes, hypothesis: no, experimentation: yes, results: yes, final: good,extra:The authors cited good references and important related works about Technical Debt analysis and effort.  Show the analysis process.  Show type of architecture issue identification. Show evaluation of Architectural Roots using som e simple statistical analysis. ";Good. the paper shows the files in architecture root and calculate the effort spend to fix the architecture roots using interview of developers.;Only one project in short time of 9 months. ;"In future work, we plan to study the process of issue removal to determine which issues are the most costly to remove and generally extend this analysis to a wider range of project domains and sizes. 
";Complete
5;Nayebi et al. 2019;8;2019;Maleknaz Nayebi, Yuanfang Cai,Rick Kazman, Guenther Ruhe, Qiong Feng, Chris Carlson, Francis Chew ;A Longitudinal Study of Identifying and Paying Down architecture debt ;2019;Architecture debt is a form of technical debt that derives from the gap between the intended and the actual architecture design. In this study we measured architecture debt in two ways: 1) in terms of system-wide coupling measures, and 2) in terms of the number and severity of architecture flaws. In recent research it was shown that the amount of architecture debt has a huge impact on software maintainability and evolution. Consequently, reducing debt is expected to make software less costly and more amenable to change. This paper reports on a longitudinal study of a healthcare communications product created by BrightSquid Secure Communications Corp. This young company is facing the typical trade-off problem of desiring responsiveness to change requests, but wanting to avoid the ever-increasing effort that the accumulation of quick-and- dirty changes eventually incurs. In the first stage of the study, we analyzed the status of the “before” system, which showed the impacts of change requests. This initial study motivated a more in-depth analysis of architecture debt. The results of this debt analysis were used in the second stage of the work to motivate a comprehensive refactoring of the software system. The third stage was a follow-on architecture debt analysis which quantified the improvements realized. Using this quantitative evidence, augmented by qualitative evidence gathered from in- depth interviews with BrightSquid’s architects, we present lessons learned about the costs and benefits of paying down architecture debt in practice. ;Conference;41st International Conference on Software Engineering: Software Engineering in Practice. ;International Conference on Software Engineering: Software Engineering in Practice;Software Engineering and Advanced Applications;Architecture debt, Cost-benefit analysis, Longitudinal study, Refactoring ;10;"In this study we measured architecture debt in two ways: 1) in terms of system-wide coupling measures, and 2) in terms of the number and severity of architecture flaws. In recent research it was shown that the amount of architecture debt has a huge impact on software maintainability and evolution. Consequently, reducing debt is expected to make software less costly and more amenable to change. This paper reports on a longitudinal study of a healthcare communications product created by BrightSquid Secure Communications Corp. 

The paper reports on the results of a longitudinal study of BrightSquid’s main software platform. In this study we performed an architecture analysis of the module structure of the platform before and after refactoring, with the goal of identifying and quantifying the architecture debt in the before and after states. To the best of our knowledge, this is the first real-world empirical study of architecture debt over a long period of time with the goal of demonstrating the benefit of improving a product’s software architecture by paying down architecture debt (through refactoring). 
RQ1: Do quantitative measures of architecture complexity change significantly before/after refactoring? 
RQ2: Do quantitative project measures of quality change significantly before/after refactoring? 
RQ3: Do qualitative perceptions of architectural quality change before/after and does this match the quantitative changes? ";Yes;Yes;No;Yes;case study;"This paper reports on a longitudinal study of a healthcare communications product created by BrightSquid Secure Communications Corp.  Real-world empirical study of architecture debt over a long period of time with the goal of demonstrating the benefit of improving a product’s software architecture by paying down architecture debt (through refactoring)";Evaluation research;Complex architectural behavioral dependencies;In this study we measured architecture debt in two ways: 1) in terms of system-wide coupling measures, and 2) in terms of the number and severity of architecture flaws.;Yes, during two years the releases were monitored to check the benefits of refactoring software architecture;"general:""maintainability, architecture flaws, architecture roots, decoupling level, propagation cost, architectural smells, Design Structure Matrix, DRSpace, code churn""
 # 
 approuch:""clique, package cycle, modularity violation, crossing, unstable interface""
 #
 tools:""DV8""";The method proposed check the time effort refactoring to fix the ATD items identified during the case study.;;The authors conducted a case study in a real IT company to check the benefits of refactoring of software architecture before and after to check the quantitative and qualitative benefits of paydown ATDI. So the study showed that reducing architecture debt has had a positive influence on productivity and quality measures for the company.;The dataset was not available to reproduce the study.;problem characterization: yes, bibliographic review: yes, data collection: yes, hypothesis: no, experimentation: yes, results: yes, final: great;Good. due to this is the first real-world empirical study of architecture debt over a long period of time with the goal of demonstrating the benefit of improving a product’s software architecture by paying down architecture debt (through refactoring). Besites, All of the architecture analyses presented in this paper are fully automated and so they can provide exactly the data needed for such measurement and benchmarking;The calculus of cost of ATDI depends on the participation of the developers from each feature and bug analysed on case study. The case study was performed only in one company.;No;Complete
7;Feng et al. 2019;-;2019;Qiong Feng, Yuanfang Cai, Rick Kazman, Di Cui, Ting Liu, Hongzhou Fang ;Active Hotspot: An Issue-Oriented Model to Monitor Software Evolution and Degradation ;2019;Architecture degradation has a strong negative im- pact on software quality and can result in significant losses. Severe software degradation does not happen overnight. Software evolves continuously, through numerous issues, fixing bugs and adding new features, and architecture flaws emerge quietly and largely unnoticed until they grow in scope and significance when the system becomes difficult to maintain. Developers are largely unaware of these flaws or the accumulating debt as they are focused on their immediate tasks of address individual issues. As a consequence, the cumulative impacts of their activities, as they af- fect the architecture, go unnoticed. To detect these problems early and prevent them from accumulating into severe ones we propose to monitor software evolution by tracking the interactions among files revised to address issues. In particular, we propose and show how we can automatically detect active hotspots, to reveal architecture problems. We have studied hundreds of hotspots along the evolution timelines of 21 open source projects and showed that there exist just a few dominating active hotspots per project at any given time. Moreover, these dominating active hotspots persist over long time periods, and thus deserve special attention. Compared with state-of-the-art design and code smell detection tools we report that, using active hotspots, it is possible to detect signs of software degradation both earlier and more precisely. ;Conference;34 ieee/acm International Conference on Automated Software Engineering (ASE);International Conference on Automated Software Engineering (ASE);Automated Software Engineering;software evolution, architecture debt;12;"In this paper, we propose a novel model, Active Hotspot (AH), that can be used to detect and monitor the emergence and evolution of software degradation by tracking how files and their relations are changed within each issue, such as adding a new feature or fixing a bug. In other words, we use issues as first-class entities of evolution, and data sources of our analysis [15]. Concretely, we first track and treat the source files that are modified to address multiple issues as seed files, calculate their architectural and semantic relations through four propagation pattern (which will be described in next paragraph) with other modified files, and form the minimal number of file groups, each of which is an active hotspot (or hotspot).  To study how changes propagate from/to seed files, we manually examined a large number of relations among files modified to address various issues. We have identified 4 recurring and repetitive patterns over many projects: 1) dissemination— changes to one file propagate to multiple dependent files (one- to-many). 2) concentration—changes to multiple files cause another file to change (many-to-one). 3) domino—changes to one file cause ripple effects to a sequence of dependent files. and 4) scattershot—changes that scatter in multiple files without syntactic dependencies. 
";Yes;No;Yes;Yes;Empirical study;"Empirical study of the evolution of 21 large-scale open source projects 
";Validation Research;System-level structure quality issues;Hotspot. Calculate a hotspot to detect problematic files and architecture debts, in terms of timelines and efficiency;The authors monitored the evolution of hostspot during the period of study comparing the revision history and issue tracker to detect problematic files. ;"general:""source code, revision history, hotspot, propagation patterns, issue tracking""
 # 
 approuch:""change-prone, bug-prone, early detection architectural problems""
 #
 tools:"" Understand , Simian,  DV8 """;No. The method proposed just check if the hotspot is increasing or decreasing and show the problematic files. There is no calculus to fix the ATD items.;;The authors proposed a model to check how is behavior of software architecture during software evolution using hotspot to define the most important part the software that should be treated with more carefully. Besides, there is an empirical study using Apache ecosystem to validate the proposed model.;An external validity is that we only studied 21 open source projects, all of which were implemented in Java and all of which are from the Apache ecosystem. While we have no reason to assume that the effects that we have studied would be different with different programming languages, we can not currently claim that our results can be generalized to projects implemented using other languages. Similarly we have no expectation that our results would differ in closed- source contexts, or projects from other OSS ecosystems, but this remains a potential threat.;problem characterization: yes, bibliographic review: yes, data collection: yes, hypothesis: yes, experimentation: yes, results: yes, final: great;Great. due to the authors propose a model - Active Hotspot - that can be used to detect and monitor the emergence and evolution of software degradation by tracking how files and their relations are changed with each issue, such as adding a new feature or fixing a bug.;" First the accuracy of our study depends on the quality of project revision histories. 
Second, our definition of active hotspot uses seed files and includes files with propagation relations with them. There may exist more effective ways to find more precise hotspot, e.g. at method-level instead of file-level. Improving and further evaluating the hotspot detection algorithm is future work.
Finally, the activeness of a system will significantly influence the detected hotspots. Besides, there is no calculus to fix the ATD items.";The amount of files choose, as the threshodld, to define the type of hotspot. Similar, to the choice of amount of issues to define the unit of evolution window. ;Complete
9;Li et al. 2014;58;2014;"Zengyang Li 
,Peng Liang, Paris Avgeriou, Nicolas Guelfi, Apostolos Ampatzoglou ";An  Empirical Investigation of Modularity Metrics for Indicating architectural technical debt;2014;Architectural technical debt (ATD) is incurred by design decisions that consciously or unconsciously compromise system-wide quality attributes, particularly maintainability and evolvability. ATD needs to be identified and measured, so that it can be monitored and eventually repaid, when appropriate. In practice, ATD is difficult to identify and measure, since ATD does not yield observable behaviors to end users. One indicator of ATD, is the average number of modified components per commit (ANMCC): a higher ANMCC indicates more ATD in a software system. However, it is difficult and sometimes impossible to calculate ANMCC, because the data (i.e., the log of commits) are not always available. In this work, we propose to use software modularity metrics, which can be directly calculated based on source code, as a substitute of ANMCC to indicate ATD. We validate the correlation between ANMCC and modularity metrics through a holistic multiple case study on thirteen open source software projects. The results of this study suggest that two modularity metrics, namely Index of Package Changing Impact (IPCI) and Index of Package Goal Focus (IPGF), have significant correlation with ANMCC, and therefore can be used as alternative ATD indicators. ;Conference;"QoSA '14: Proceedings of the 10th international ACM Sigsoft conference on Quality of software architectures  CompArch'14: Federated Events on Component-Based Software Engineering and Software Architecture";"international ACM Sigsoft conference on Quality of software architectures  ";Quality of software architecture;Architectural technical debt, modularity metric, commit, software architecture ;10;"In this work, we empirically investigate the ability of existing modularity metrics to substitute ANMCC as ATD indicators, through a holistic multiple case study on thirteen open source projects. The main contribution of this work is the empirical evidence supporting that two of the investigated modularity metrics, i.e., Index of Package Changing Impact (IPCI) and Index of Package Goal Focus (IPGF), have significant negative correlations with ANMCC – the ATD indicator. Thus, the two software modularity metrics (IPCI and IPGF) can be used as indicators of ATD of a system. The merit of using IPCI and IPGF as ATD indicators is that they can be automatically calculated using a single version of source code, while the calculation of ANMCC requires commit history information of a project which is not always available. 

The goal of this study, described using the Goal-Question-Metric (GQM) approach [2], is: to analyze modularity metrics for the purpose of evaluation with respect to their ability to act as substitutes of ANMCC, for indicating ATD, from the point of view of software architects in the context of OSS evolution. 
Based on the above mentioned goal, we have extracted two research questions (RQs): 
RQ1: Are there modularity metrics that correlate with ANMCC? 

RQ2: Which modularity metrics have the most accurate 
correlation with ANMCC? 



";Yes;No;Yes;Yes;Case study, Empirical investigation;"Empirical investigation.   This study is a holistic multiple case study, in the sense that we investigate multiple OSS projects, i.e., cases, and from each case we extract a single unit of analysis. In this study, as unit of analysis we use the pair of two selected releases of an OSS project. 
";Validation Research;Architectural compliance issues;Index of Package Changing Impact (IPCI),  Index of Package Goal Focus (IPGF), Average Number of Modified Components per Commit (ANMCC);The authors monitored the evolution of Indexes during the period of study comparing the revision history of the source code of each release of a selected OSS project.;"general:""modularity, average number of modified components per commit, ANMCC, index of package changing impact, IPCI, index of package goal focus,  IPGF, source code, revistion history, ""
 # 
 approuch:""modularity metrics, Spearman’s correlation tests""
 #
 tools:""No""";No. The method proposed just calculates the ATD indexes but does not calculate the cost to fix it.;;The authors conducted an experimentation with Opens Source Software witth real data. The findings showed that the modularity metrics IPCI and IPGF can be used to indicate ATD. Besides, it is possible to monitoring if the ATD indexes are increasing or decreasing.;The authors conducted a study using only C# OSS project, so it not possible to generalize to other types programing languages and private IT projects.;problem characterization: yes, bibliographic review: yes, data collection: yes, hypothesis: no, experimentation: yes, results: yes, final: great;Great. The authors proposed a new ATD index called IPCI (Index of package changing impact) based on modularity metrics that is no necessary to get access to source code log commits. Besides, we consider that the estimation of ATD should be calculated on real data (i.e., source code), and the estimation makes more sense within a relative short term, e.g., between two releases. That is, the estimation of the next release is based on the real data of this implemented release. ;In this case study, only C# OSS projects were selected and used to validate the correlation between modularity metrics and ANMCC. Consequently, the conclusion drawn is only valid for C# projects. There is a need of conducting more studies for the projects written in other object-oriented languages, such as Java.;Based on the results and findings of this work, we plan to do further research in the following directions. First, we intend to validate the correlation between modularity metrics and ANMCC with Java projects. Second, it will be interesting to define new system-wide modularity metrics or adapt existing modularity metrics defined in other perspectives (e.g., complex networks [14]), and investigate the correlation between the metrics and ATD indicators. We expect that the new modularity metrics can improve the accuracy or take less effort of predicting ANMCC. Third, it is practically valuable to develop plugins to calculate the modularity metrics IPCI and IPGF for IDE tools (e.g., in VS2012 or Eclipse).;Complete
10;Martini et al. 2016;34;2016;Antonio Martini, Jan Bosch;An Empirically Developed Method to Aid Decisions on Architectural Technical Debt Refactoring: AnaConDebt ;2016;Architectural Technical Debt is regarded as sub-optimal architectural solutions that need to be refactored in order to avoid the payment of a costly interest in the future. However, decisions on if and when to refactor architecture are extremely important and difficult to take, since changing software at the architectural level is quite expensive. Therefore it is important, for software organizations, to have methods and tools that aid architects and managers to understand if Architecture Technical Debt will generate a costly and growing interest to be paid or not. Current knowledge, especially empirically developed and evaluated, is quite scarce. In this paper we developed and evaluated a method, AnaConDebt, by analyzing, together with several practitioners, 12 existing cases of Architecture Debt in 6 companies. The method has been refined several times in order to be useful and effective in practice. We also report the evaluation of the method with a final case, for which we present anonymized results and subsequent refactoring decisions. The method consists of several components that need to be analyzed, combining the theoretical Technical Debt framework and the practical experience of the practitioners, in order to identify the key factors involved in the growth of interest. The output of the method shows summarized indicators that visualizes the factors in a useful way for the stakeholders. This analysis aids the practitioners in deciding on if and when to refactor Architectural Technical Debt items. The method has been evaluated and has been proven useful to support the architects into systematically analyze and decide upon a case. ;Conference;IEEE/ACM 38th IEEE International Conference on Software Engineering Companion ;International Conference on Software Engineering Companion ;Software Engineering;Management, Measurement, Design, Economics;10;Since our goal was the development of a method, or else to design an artifact to be used in practice. To develop a process to identify and quantify ATD itens;Yes;Yes;No;Yes;Case study, industrial practice, expert opinion, observation;This research process can be seen as a longitudinal case study, in which a method is created and evaluated. The difference is that, instead of developing the method offline and evaluating it once, we continuously refined the method with multiple and iterative evaluations of the artifact involving several stakeholders in several organizations. case study in industry;Evaluation research;Architectural compliance issues;"Principal and Interest of ATD.   There is a set of pre-defined ATD based on a set of previously analyzed cases. These set of ATD is used the identify ATD based on software architect.";The Principal and Interest is analysed by Software Architects and Project Managers for each release.;"general:""source code, software architecture documentation, business documentation, revision history, release plan""
 # 
 approuch:""framework AnaConDebt, catalog, taxonomy""
 #
 tools:""proprietary formulas""";Using particular formulas created by AnaConDebt framework related to principal and interest to calculate the effort to fix the ATD Item identified.;;The authors proposed a method to identify and calculate the principal and interest of ATDI. The case study was conducted in 6 large IT company with real data in real IT projects.;The authors proposed an manual aprouch called AnaConDeb to identify ATDI and calculate the principal and Interest by stekholder for each release. So, it is possible that values changes depends on the company and the steakholders;problem characterization: yes, bibliographic review: yes, data collection: yes, hypothesis: no, experimentation: yes, results: yes, final: great;Great. due to The authors proposed a method to identify and calculate the principal and interest of ATDI. The case study was conducted in 6 large IT company with real data in real IT projects. Besides, the research process was based on Design Science Research.;There are some limitations in this study. Most of the effort measures used for calculating the different components are based on the experiences of the experts involved. This might have injected some bias in the study. However, the overall framework and the components that can be used to estimate ATD refactoring are quite generalizable, the indicators have been considered as useful and the decision making process proper. The different metrics that can be used as input needs to be further studied, however they usually depend on the different company. Another limitation is the learning curve: it took a while before the architects would employ the method, but after the sessions, they recognized that the method was very logical and that the process would probably be much shorter as the method was repeated and the tasks of collecting information split among the architects.;Future work aims at increasing the precision of these estimations with more precise measures. We have to keep in mind that ATD management is prevalently a risk assessment practice, and until better prediction models have been created to predict the cost of architecture anti-patterns (as confirmed in a recent systematic review [8]), the architects’ decisions are based on gut feeling and estimations based on their subjective experiences [20]. However, structuring such process of decision making by applying the method AnaConDebt, has been proven useful in order to make the decision around ATD refactoring based to concrete factors that are causing the interest to be paid in the future, and therefore it would explicit and increase the architects’ knowledge for making informed decision on the ATD refactoring cases.;Complete
13;Xiao et al. 2016;73;2016;Lu Xiao, Yuanfang Cai, Rick Kazman, Ran Mo, Qiong Feng ;Identifying and Quantifying Architectural Debt ;2016;Our prior work showed that the majority of error-prone source files in a software system are architecturally connected. Flawed architectural relations propagate defects among these files and accumulate high maintenance costs over time, just like debts accumulate interest. We model groups of architecturally connected files that accumulate high maintenance costs as architectural debts. To quantify such debts, we formally define architectural debt, and show how to automatically identify debts, quantify their maintenance costs, and model these costs over time. We describe a novel history coupling probability matrix for this purpose, and identify architecture debts using 4 patterns of architectural flaws shown to correlate with reduced software quality. We evaluate our approach on 7 large-scale open source projects, and show that a significant portion of total project maintenance effort is consumed by paying interest on architectural debts. The top 5 architectural debts, covering a small portion (8% to 25%) of each project’s error-prone files, capture a significant portion (20% to 61%) of each project’s maintenance effort. Finally, we show that our approach reveals how architectural issues evolve into debts over time. ;Conference;IEEE/ACM 38th IEEE International Conference on Software Engineering ;International Conference on Software Engineering ;Software Engineering;Software Architecture, Software Quality, Technical Debt ;11;"Although the concept of TD has been influential, it has until now largely been a metaphor. The dierences with real (financial) debt are crucial. A real debt always starts from a principal, and grows with a certain interest rate. How to quantify the principal and interest rate in software investments has been a challenge. Our goal is to advance the understanding and management of architectural debt, a type of technical debt, by quantifying it. 
We define the concept of architectural debt (ArchDebt) as a tuple consisting of: 1) a group of architecturally connected files, and 2) a model of the maintenance cost growth for such files. Based on this definition, we contribute an approach to automatically locate architecture debts. Once we locate each debt we model its growth using regression models. Our approach to identify ArchDebt has two parts. We first create a novel history coupling probability (HCP) matrix to manifest the probability of changing one file when another file is changed. Then we index file groups through the lens of 4 patterns of prototypical architectural flaws that have been shown to correlate with reduced software quality [21], namely hub, anchor-submissive, anchor-dominant, and modularity violation. 
Given an ArchDebt, we quantify the maintenance costs (approximated by bug-fixing churn) spent on the files involved in the debt. From the costs incurred in each release, we can model the growth trend using linear, logarithmic, exponential or polynomial regression models. These models represent coherent scenarios of stable, reducing, increasing, and fluctuating maintenance interest rates respectively. Finally, we rank the identified architectural debts according to the maintenance costs they have accumulated. 
We have evaluated our approach using seven Apache open source projects, and identified many instances (between 74 and 204) of ArchDebts in each project. The results show that a significant portion (from 51% to 85%) of the main- tenance e↵ort in each project is consumed by paying inter- est on these debts, and that non-trivial portions (20% to 61% ) of the maintenance e↵ort is consumed by just five ArchDebts, which represent a small portion of all error- prone files. Our evaluation also revealed that about half of the identified debts fit linear regression models, indicating a steady increase in the penalty that these debts incur. About 1/3, 1/10, and less than 1/10 of all debts fit polynomial, logarithmic, and exponential models respectively, indicating the interest rate trends of these debts can vary drastically. Finally, we qualitatively analyzed the design problems be- hind debts, and how these evolve over time. 

To evaluate the effectiveness of our approach, we investi- gate the following research question:
RQ: Whether the file groups identified in ArchDebts generate and grow significant amount of maintenance costs? That is, are they true and significant debts? If the identified file groups only consume a small portion of overall maintenance efort, then they do not deserve much attention. Similarly, if the identified file groups cover a large portion of the system itself, it is not surprising if they also consume the majority of maintenance efort. In both cases, we cannot claim that they are debts worthy of attention. 



";Yes;No;Yes;Yes;Empirical study;"We chose 7 Apache open source projects as our evaluation subjects. These projects dier in scale, application domain, length of history, and many other project character- istics. They are: Camel—a integration framework based on Enterprise Integration Patterns. Cassandra—a distributed DBMS. CXF—a Web services framework. Hadoop—a frame- work for reliable, scalable, distributed computing. HBase— the Hadoop distributed, scalable, big data store. PDFBox— a library for working with PDF documents. and Wicket—a component-based web application framework. 
";Validation Research;Architecture Smells;It was created a specific concept about ArchDebt that derives a set of formulas. It is described in terms of group of files.;It was monitored the evolution of ArchDebts through releases that are evaluated.;"general:""Design Rules Spaces, Design Structure Matrix, Architecture Issues, Architectural Smells, Hotsport pattern, unstable interface, modularity violation, unhealthy inheritance, cyclic dependency, DRSpace, source code, revision history, bug track, modularity violation, code churn, debt churn""
 # 
 approuch:""ArchDebt framework, history coupling probability (HCP) matrix, Ranking: Identify High-maintenance ArchDebt, architechtural debt evolution""
 #
 tools:""titan, understand""";It was calculated the cost of interest for identifying ArchDebt using a linear regression model in terms of set of files.;;The authors proposed a method do identify and measure ATD using the technique DRSapce and architecture debt to generate a HPC Matrix and identify a ranked list of archdebt incluind its cost fo fix them.;Due to the study used only Open Source Software from Apache Project, it was not possible to calculate the effort to tix the ATD in terms of time or money. The calculation of cost proposed used the amount of lines necessary to fix the ATD.;problem characterization: yes, bibliographic review: yes, data collection: yes, hypothesis: yes, experimentation: yes, results: yes, final: great;Good. due to the authors showed a method do identify and measure of ATD using a framework applied in a real case using a set of Apache project using analsys of sequence of releases;"First, since we have only examined 7 projects and all of these are Apache projects, we can not guarantee that our results will generalize to other projects with different cultures and organizational policies. Second, our approach has the limitation that it relies on revision history to iden- tify architectural debt.
For projects without enough history data, our approach can still identify groups of files with the potential to become architectural debt
Third, our approach relies on mining error-prone files from a project’s revision history and bug tracking data. We use the bug report ID that developers enter into commits to locate error-prone files.";"We plan to evaluate the eficiectiveness of our approach on projects without enough history in our future work. In our future work, we plan to explore more effort proxies, and we are collaborating with an industry project that records actual effort data, and we plan to compare this with our proxy measures of effort.
";Complete
14;Verdecchia 2018;7;2018;Roberto Verdecchia;Identifying Architectural Technical Debt in Android Applications through Automated Compliance Checking ;2018;By considering the fast pace at which mobile applications need to evolve, Architectural Technical Debt results to be a crucial yet implicit factor of success. In this research we present an approach to automatically identify Architectural Technical Debt in Android applications. The approach takes advantage of architectural guide- lines extraction and modeling, architecture reverse engineering, and compliance checking. As future work, we plan to fully automate the process and empirically evaluate it via large-scale experiments. ;Conference;"5th International Conference on Mobile Software Engineering and Systems 
";"International Conference on Mobile Software Engineering and Systems 
";Mobile Software ;Software Architecture, Technical Debt, Android, Compliance Checking;2;"In this research we present an approach to automatically identify Architectural Technical Debt in Android applications. The approach takes advantage of architectural guidelines extraction and modeling, architecture reverse engineering, and compliance checking. 
";No;No;No;No;Toy examples;"In this research we present an approach to automatically identify Architectural Technical Debt in Android applications 
";Solution proposal;Not specified;Android ATD hotspots, i.e. a set of files.;No;"general:""Architecture Description Language, ADL, Objet Constraint Language, ATD Hotsports""
 # 
 approuch:""Android architecture guideline extraction, Android reference architecture establishment, Reverse engineering of implemented architecture, Compliance checking, Quantitative assessment of compliance violations""
 #
 tools:""ACME-Generator Tool""";No;;The practical idea of the study about ATDI approuch hotspot identification in Android application is good.;The practical idea of the study about ATDI approach hotspot identification in Android application is good.;problem characterization: yes, bibliographic review: no, data collection: yes, hypothesis: no, experimentation: no, results: no, final: weak;Weak. The idea of the study about ATDI approuch hotspot identification in Android application is good, but there is no scientific rigor in the paper. ;The study is a short paper with only two pages.; As future work, we plan to fully automate the process and empirically evaluate it via large-scale experiments.;Complete
15;Zitzweitz et al. 2019;3;2019;Alexander von Zitzewitz ;Mitigating Technical and Architectural Debt with Sonargraph Using static analysis to enforce architectural constraints ;2019;Sonargraph is a static analyzer with a focus on software architecture and metrics. The motivation to create Sonargraph came from the assumption that architectural debt (aka structural debt) is the most toxic form of technical debt. Repairing a broken architecture requires global and high-risk changes, while fixing other forms of technical debt mostly involves low-risk local changes. Therefore, the tool enables architects and developers to formally describe their architectural blueprint using a custom DSL (domain specific language). Once defined architectural rules can be checked and enforced in an automated way in all stages of the development process. This guarantees that a software system will never end up as the notorious “big ball of mud”. Sonargraph currently supports Java, C#, C/C++ and Python and is used by hundreds of organizations worldwide. ;Conference;International Conference on Technical Debt (TechDebt);International Conference on Technical Debt (TechDebt);Technical Debt;"software artchitecture, software metrics, architectural debt
";2;It is a presentation about Sonargraph is a static analyzer tool with a focus on software architecture and metrics. The motivation to create Sonargraph came from the assumption that architectural debt (aka structural debt) is the most toxic form of technical debt. ;No;No;No;No;Tool evaluation;It is a presentation of the features and characteristics of a tool.;Solution proposal;Architectural compliance issues;Compliance checking;issue management workflow ;" general:""ARCHITECTURE DSL, Architecture violation, package analysis, source code""
 # 
 approuch:""Architecture Violation""
 #
 tools:""Sonargraph""";No;;The idea of this technical paper is to show the main features from Sonargraph, which is an important tool to check software architecture validation and important metrics such as cyclomatic complexity, propagation cost, and cyclicity.;"Weak. Actually, this is a technical paper with only two pages, and there is no scientific rigor. It is just a tool evaluation describing the features of this tool.
";problem characterization: no, bibliographic review: no, data collection: no, hypothesis: no, experimentation: no, results: no, final: poor;Weak. The paper is more technical and describe a tool called sonargraph and its importance to check the software architecture. However, it is not a scientific study.;There is no data or experimentation about the study.;No;Complete
16;Martini and Bosch 2017;14;2017;Antonio Martini, Jan Bosch;On the interest of architectural technical debt: Uncovering the contagious debt phenomenon ;2017;"A known problem in large software companies is to balance the prioritization of short‐term and long‐term business goals. As an example, architecture suboptimality (Architectural Technical Debt), incurred to deliver fast, might hinder future feature development. However, some techni- cal debt generates more interest to be paid than other. We conducted a multi‐phase, multiple‐case embedded case study comprehending 9 sites at 6 large international software companies. We have investigated which architectural technical debt items generate more interest , how the interest occurs during software development and which costly extra‐activities are triggered as a result. We presented a taxonomy of the most dangerous items identified during the qualitative investigation and a model of their effects that can be used for prioritization, for further investigation and as a qual- ity model for extracting more precise and context‐specific metrics. We found that some architectural technical debt items are contagious, causing the interest to be not only fixed, but potentially compound, which leads to the hidden growth of interest (possibly exponential). We found important factors to be monitored to refactor the debt before it becomes too costly. Instances of these phenomena need to be identified and stopped before the development reaches a crises. 
";Journal;Journal of Software: Evolution and Process;Journal of Software: Evolution and Process;Software Evolution;"agile software development, architectural technical debt, effort, multiple case study, qualitative model, sociotechnical phenomena 
";18;"In this paper, we conduct an empirical study involving several organizations and several practitioners. The aim is to understand which ATD items are the most dangerous for accumulated interests. Moreover, it is important to understand what kind of interest is associated with the various ATD, both for their recognition during development and for the development of methods, tools, and measurements. In particular, we need to understand how compounded interest, the costliest interest, is accumulated in practice. We therefore answer the following research questions: 
RQ1: What are the most dangerous classes of ATD in terms of generated interest? 
RQ2: What kind of interest is triggered by different classes of ATD? 
RQ3: Are there socio‐technical anti‐patterns causing the ATD and its interest to increase over time causing the accumulation of compounded interest? 
RQ4: How can contagious debt and, therefore, the accumulation of compounded interest, be identified and stopped?

The main contributions of the paper are 

• We have qualitatively developed and validated (through multiple sources) a taxonomy of effortful ATD classes. 
• We link specific interests to specific classes of ATD by identifying recurring sociotechnical phenomena and consequent extra activi- ties that could lead to extra costs 
• We have conceptualized, defined, and found empirical evidence of, an important phenomena of ATD, contagious debt. this is related to the occurrence of sociotechnical chains of events (that we call vicious cycles) responsible for the increment of interest and that potentially lead to the accumulation of compound interest. 
We have identified propagation factors, responsible for making the ATD contagious. By monitoring the growth of such factors, the practitioners can proactively avoid the accumulation of compound interest. 
";Yes;Yes;No;Yes;Case study;"We conducted a 2‐year long, multiple‐case, embedded case study involving 9 Scandinavian sites in 6 large international software development companies. case study in industry, industrial practice, expert opinion, observation, empirical study in industry
";Evaluation research;Not specified;Contagious debt;"Yes, after each release using a proprietary method. The interest is monitored by analysing each ATD class defined in proprietary taxynomy.  These factors can be proactively monitored to strategically refactor the ATD, before it becomes too costly to be repaid. ";"general: ""It was created a taxonomy about ATD itens to identify ATD Contagius debt""#approuch: """"#tools:""""";It is provided by a formula that is a sum of cost ATDI estimated by developer's participation. ;Yes. identify, measure, prioritize, repayment, monitoring;;;problem characterization: yes, bibliographic review: yes, data collection: yes, hypothesis: no, experimentation: yes, results: yes, final: good;Great;;;Complete
17;Fontana et al. 2016;16;2016;Francesca Arcelli Fontana, Riccardo Roveda, Marco Zanoni ;Tool support for evaluating architectural debt of an existing system: An experience report ;2016;"During software development, maintenance and evolution, we can assess the quality of code, design and architecture to capture hints of possible problems and face them as soon as possible. We can capture signals of architecture erosion in di↵erent ways by exploiting several tools with the aim to identify architectural violations, architectural smells or other relevant features. In this paper, we provide our experience report in using three known tools to capture in- formation that can be useful to identify and evaluate the architectural debt of an application. We outline the main diferences among these tools and the results they produce. 
";Symposium;"SAC 2016, April 04-08, 2016, Pisa, Italy   SAC '16: Proceedings of the 31st Annual ACM Symposium on Applied Computing";Symposium on Applied Computing;Applied computing;Architectural deb, Tool experimentation, Architecture assessment ;3;"In this paper, we provide our experience report in using three known tools to capture information that can be useful to identify and evaluate the architectural debt of an application.   To evaluate 3 tools (Sonargraph, SonarQube and Fusion) to check architectural debt.
This paper aims to describe our experimentation using these tools, by ana- lyzing diferent systems. We also report the results obtained analyzing an application we developed for the crawling and analysis of open source projects [1]. We focus our attention on comparing the following architectural evaluation issues: 1) the Quality Indexes the tools compute. 2) the Results Inspection capabilities of the data the tools provide. 3) the Data extracted by the tools on the same system. 
";Yes;No;Yes;Yes;experience report;"we provide our experience report in using three known tools to capture information that can be useful to identify and evaluate the architectural debt of an application. 
";Validation Research;Not specified;No;No;" general:""tool evaluation, package evaluation, architectural smells, code smells, Technical Debt Index, Architectural Violation, cyclic packages, Technical Debt ratio, cycles, cyclic dependencies, Unstable dependencies""
 # 
 approuch:""analys of open source project""
 #
 tools:""Sonargraph, SonarQube,Fusion""";No;No;The study showed tools that analysis software architecture structure and some metrics about this.;There is no link to dataset of evaluation.;problem characterization: yes, bibliographic review: no, data collection: no, hypothesis: no, experimentation: no, results: yes, final: poor;Weak. Even the study evaluates a set of tools to check architectural debt with real data java systems, the paper is only a tool evaluation of features that check architectural debt.;The study should be share the dataset used in evaluation of tools.; In future experiments, we aim to similarly consider other tools, e.g., the commercial tool CAST, tools that provide dependency analysis and other tools developed in academia, e.g., Hotspot Detector, TamDera. Moreover, we are interested in inspecting other dimensions of archi- tectural debt, as the history of projects, and in analyzing large-scale industrial systems.;Complete
21;Li et al. 2015;36;jul-05;"Zengyang Li,  Peng Liang, Paris Avgeriou 
";Architectural Technical Debt Identification based on Architecture Decisions and Change Scenarios ;2015;Architectural technical debt (ATD) is incurred by design decisions that intentionally or unintentionally compromise system-wide quality attributes, particularly maintainability and evolvability. ATD is harmful to the system’s long-term health, thus it needs to be identified for further management. However, existing ATD identification approaches are mainly based on source code analysis and thus suffer from certain shortcomings: they can only identify issues at the system implementation. they can only be employed after the systems is implemented in code. they lack a mechanism to confirm whether the potential ATD identified is real ATD or not. To address these issues, we proposed an ATD identification approach based on architecture decisions and change scenarios. To evaluate the effectiveness and usability of this approach, we conducted a case study with an information system in a large telecommunications company. The results show that the proposed approach is useful and easy to use, and it supports release planning and ATD interest measurement. ;Conference;IEEE/IFIP Conference on Software Achitecture;Conference on Software Achitecture;Software Architecture;Architectural technical debt, architectural technical debt identification, architecture decision, change scenario;10;"To overcome the shortcomings of source code analysis- based ATD identification approaches, we propose to identify ATD based on ADs made during the architecting process and change scenarios for software maintenance and evolution. An AD is a design decision that affects the architecture design space for a target software system [5]. A change scenario is a maintenance or evolution task to be performed in the software system. The proposed approach takes ADs and change scenarios as input, and then comes up with ATD items that are caused by the ADs or negatively impact the change scenarios. To validate our proposed approach, we conducted an industrial case study which evaluates the effectiveness and usability of identifying ATD using this approach. The results show that the approach is useful and easy to use, and it supports release planning and ATD interest measurement. 
RQ1: How effective is the approach?  
RQ1.1: How useful is the ATD identification approach for identifying ATD in the project?  
RQ1.2: How appropriate is the granularity of the change scenarios used in the ATD identification approach for ATD interest measurement in the project?  
RQ1.3: How helpful are the identified ATD items to the release planning of the project?   
RQ2: How easy is it to execute the ATD identification approach for the project?  
 
  
   
";Yes;Yes;No;Yes;Case study;"Case study.   This is an embedded single case study, since multiple units of analysis (i.e., the participants) are studied for one case: an information system in a large telecommunications company in China. Industrial practice, expert opinion
";Evaluation research;Architectural compliance issues;"ATD Itens based on templated suggested by authors  .";The approach is performed for each release using expert evaluation (Software Architect from project evaluated);" general:""software architectural documentation, architecture decision, quality attributes, ATD Item, ATD list, Change scenario, architecture decision template, architecture diagram, specialist analysis, revision history, release plan""
 # 
 approuch:""ATD Identification based on change scenarios""
 #
 tools:""no""";For each ATD item is calculated principal and interest using person-days as unit to measurement. ;;The authors proposed an approuch to identify and measure ATD itens via architectural decisions during the redesing process. Thus, the ATD can be identified and calculate without to have access to source code of the project. The architects agreed that associating ATD items to concrete impacted change scenarios is helpful to estimate the interest of ATD items.The development team members considered that the scenario-based part of the approach is particularly useful and easy to conduct, since they are familiar with the change scenarios and are even under pressure from delayed change scenarios that are negatively impacted by certain ATD items.;The process is manual and it is necessary a participation of the architect to plan and evaluate each release. So, the principal and the interest are estimated manually according interpretation of specialist about ATDI;problem characterization: yes, bibliographic review: yes, data collection: yes, hypothesis: no, experimentation: yes, results: yes, final: good;Great. The authors proposed an approuch to identify and measure (in man-days) ATD itens via architectural decisions during the redesing process. Thus, the ATD can be identified and calculate without to have access to source code of the project. ;The process should be automated or seme-autormated using a specific tool to aid the architect. Some users (e.g., new developers) may not be familiar with ADs and ATD items, though the templates provided. The preparation of ADs may take time when the ADs are not documented, especially when the ADs were made a long time ago as the knowledge about ADs tends to vaporize.;We plan to replicate the case study in more industrial projects with different sizes and from various domains. We also plan to customize the approach in order to make it suitable for an agile context, with appropriate tool support.;Complete
22;Martini et al. 2014;86;2014;"Antonio Martini, Jan Bosch, Michel Chaudron 
";Architecture Technical Debt: Understanding Causes and a Qualitative Model ;2014;A known problem in large software companies is to balance the prioritization of short-term with long-term responsiveness. Specifically, architecture violations (Architecture Technical Debt) taken to deliver fast might hinder future feature development, which would hinder agility. We conducted a multiple-case embedded case study in 7 sites at 5 large companies in order to shed light on the current causes for the accumulation of Architectural Technical Debt that causes effort. We provide a taxonomy of the factors and their influence in the accumulation of debt, and we provide a qualitative model of how the debt is accumulated and recovered over time. ;Conference;"40th Euromicro Conference on Software Engineering and Advanced Applications 
";"Euromicro Conference on Software Engineering and Advanced Applications 
";Software Engineering and Advanced Application;architectural technical debt, agile software development, development speed, software life-cycle, influencing factors, qualitative model, Grounded Theory ;8;"The study of such subject would also compensate the lack, in ASD (Agile Software Development) frameworks, of activities for enhancing agility in the task of developing and maintaining software architecture in large projects.

In the context of large-scale ASD, the research questions that we want to inform are:
RQ1: What factors cause the accumulation of ATD?
RQ2: What are the current trends in practice in the accumulation and recovery of ATD over time?

 The main contributions of the papers are therefore:
- A taxonomy of the causes for ATD: we provide the factors for the explanation of the phenomena such as accumulation and recovery of ATD. These factors might be studied and treated separately, and offer a better understanding of the overall phenomenon.
- A qualitative model of the trends in accumulation and recovery of ATD over time. Such model:
-- Shows the strictly increasing trend of ATD accumulation and how it eventually reaches a crisis point. We connect such phenomenon to the different factors and their influence on such accumulation.
-- Helps identifying problem areas and points in time for the development of practices that would 1) avoid accumulation of ATD and/or 2) ease the recovery of ATD. Such practices would be aimed at delaying the crisis point.";Yes;Yes;No;Yes;Case study;In this paper we have employed a 1-year multiple-case embedded case-study involving 7 different sites in 5 large Scandinavian companies in order to shed light on the phenomenon of accumulation and recovery of ATD. case study in industry, industrial practice, expert opinion, observation, empirical study in industry;Evaluation research;Architectural compliance issues;The authors proposed a crisis point based on ATD accumulation from itens collected using ATD Taxonomy.;The ATD items are monitored during releaase planing via expert evaluation that use the ATD taxonomy.;" general:""Agile Software Development, Taxonomy of ATD, refactoring, source code, business factory, architecture documentation, human factor,  ""
 # 
 approuch:""Taxonomy of ATD, framework to identify ATD, specialist analysis""
 #
 tools:""no""";The authors have been defined a crisis point over the time to calculate the moment to pay the ATD.;;The study shows factors that cause accumulation of ATD using an approuch that monitoring a .Crisis point of ATD Accumulation.. Beside, the study show a taxonomy of the causes for ATD. In addition, the study employed a case study using real data from 5 large Scandinavian Software Companies. The companies adopted Agile Software Developement (ASD) as a Software life-cycle process;There is no repliaction kit to reproduce the study;problem characterization: yes, bibliographic review: yes, data collection: yes, hypothesis: yes, experimentation: yes, results: yes, final: good;Good.due to the authors proposed a taxonomy of ATD accumatlion;The graphs in this paper are not meant to represent precise data coming from a measurement system. Therefore the steepness of the curves and the projections might vary in real context. The magnitude for the contribution of each factor is also to be further assessed. However, we offer the recognition of factors that are not necessarily possible to be measured and therefore discovered by quantitative analysis, such as urgency and uncertainty. The results are qualitatively developed through a thorough research process and using a wide amount of qualitative data coming from more than 30 informants from 7 sites and with different roles, which allowed as to compare and test statements among themselves. Furthermore, architecture documentation has been evaluated as well as secondary data. This has allowed us to apply source triangulation.;"Some open issues that require further investigation are:
• It remains unclear when is best to conduct a refactoring. The unknown effects of combining the refactoring with uncertainty and urgency suggest further investigation.
• We have studied principally the delays that the ATD have on long term development. What needs to be more investigated are the short-term benefits that are gained by the accumulated ATD.";Complete
27;Martini et al. 2016;9;2016;Antonio Martini, Erik Sikander, Niel Madlani;Estimating and Quantifying the Benefits of Refactoring to Improve a Component Modularity: a Case Study ;2016;In recent years, research and industry's attention has been focused on maintaining a system that would both decrease time to market in the short term and assure a sustainable feature output and smooth maintenance operations in the long run. A related phenomenon has been identified in Architectural Technical Debt: if the system architecture is sub-optimal for long-term business goals, it needs to be refactored. A key property of the system assuring long-term goals consists on modularity, or else the ability to decouple different components: such property allows the product to be evolved without costly changes pervading the whole system. However, understanding the business benefits of refactoring to achieve modularity is not trivial, especially for large refactorings involving substantial architectural changes. We have conducted a case study in a large company, analyzing a case of refactoring a component to achieve modularity. We report a comparative study of a refactored against a non-refactored component. We found that the modularization would be repaid in several months of development and maintenance. We present a method to calculate the effort saved by the modularization and an equation for calculating and quantifying the development and maintenance benefits of refactoring. ;Conference;"Euromicro Conference on Software Engineering and Advanced Applications 
";"Euromicro Conference on Software Engineering and Advanced Applications 
";Software Engineering;Software Management, Refactoring, Estimation, Technical Debt, Modularization, Software Architecture;8;"We have conducted a case study in a large company, analyzing a case of refactoring a component to achieve modularity. We report a comparative study of a refactored against a non-refactored component. We found that the modularization would be repaid in several months of development and maintenance. We present a method to calculate the effort saved by the modularization and an equation for calculating and quantifying the development and maintenance benefits of refactoring.   RQ – How can we estimate, in a quantitative way, the benefits of modularizing a component?   We have conducted a case study in a large software company: we have studied a case in which the functionality of a component was modularized and used by new applications. By comparing the development and maintenance effort between the two solutions, we developed a formula quantifying the refactoring benefits. 


";Yes;Yes;No;Yes;Case study;It was conducted a holistic case-study in a large software company. case study in industry, industrial practice, expert opinion, observation, empirical study in industry ;Evaluation research;System-level structure quality issues;It is calculated the effort of modularization in Files that was not modularized. ;It was applied the framework for each release evaluated. It is a manual process that there is no tool to support this. ;" general:""modularization, code churn, source code, revision history, complexity, refactoring, specialist analysis, files, components""
 # 
 approuch:""method to select critcial files to refactoring""
 #
 tools:""proprietary formula""";"It is used a formula to calculate the effort in time to fix the ATD items. 
The effort use the unit DWM/Mounth that means man-hours each month.";;The authors done a case study in a large IT company using a large software product in long term with real data. The authors proposed a method to identify ATD focus on files that should be refactored and the methods helps to calculate the estimation effort to fix this ATD. A formula quantifying the refactoring benefits.;The authors proposed a manual method to calculate the effort to fix the ATD. ;problem characterization: yes, bibliographic review: yes, data collection: yes, hypothesis: yes, experimentation: yes, results: yes, final: good;Good. due to the study show an approuch to identify the ATD, Monitoring and Calculate the effort to fix it.;It was necessary to do many interviews with developers to get the estimation effort about ATD fix. So, the process to calculate the effort of ATD fix majority manual.;Also, the method can be supported by a tool: possible future work is related to the development of support to input the estimation data to be combined with the modularity tool in order to make the estimation more cost efficient. ;Complete
30;Martini et al. 2018;13;2018;"Antonio Martini,
Francesca Arcelli Fontana, 
Andrea Biaggi, 
Riccardo Roveda,";Identifying and Prioritizing Architectural Debt Through Architectural Smells: A Case Study in a Large Software Company;2018;"Architectural technical debt can have a huge impact on software maintainability and evolution. Hence, different architectural violations, detected as architectural smells, need to be identified and refactored. In this paper, we conducted a multiple case-study on several architectural smells detected in four industrial projects. We conducted an in-depth investigation with a questionnaire, interviews and thorough inspection of the code with the practitioners. We evaluated the negative impact of the technical debt detected by the architectural smells, their difficulty to be refactored and the usefulness of the detection tool. The results show that practitioners appreciated the help of automatic detection, and that they prioritize refactoring architectural debt that causes more negative impact despite the higher refactoring effort.
";Conference;"European Conference on Software Architecture
ECSA 2018: Software Architecture pp 320-335";"European Conference on Software Architecture
";Software Architecture;Not available;16;"In this study we aim at answering the following RQs:
– RQ 1: How do AS help practitioners in identifying ATD?
– RQ 2: How do practitioners prioritize ATD revealed through AS?
– RQ 2.1: How is the AS’s negative impact (interest) perceived by the practitioners?
– RQ 2.2: What is the refactoring cost (principal) of AS perceived by the practitioners?

By answering RQ1, we aim at understanding if AS are useful to automatically identify ATD in industrial projects. Answering RQ2 means answering the combination of RQ2.1 and RQ2.2: understanding what negative impact is generated by the ATD and what cost of refactoring is required. This would help identifying which AS are more critical for the practitioners to prioritize.

The objectives of the case-study were: 
automatically identify the AS in the industrial projects (RQ1) 
evaluate the output in terms of negative impact (RQ2.1) and cost of refac- 
toring (RQ2.2), to prioritize the ATD. 

";Yes;Yes;No;Yes;Case study;"In summary, with this case-study, we make a first step towards understanding how practitioners can semi-automatically detect and prioritize ATD 

We conducted a multiple case-study in a large, international company located in Sweden. In particular, we automatically analyzed four projects and we assessed the output with the practitioners responsible for the development and mainte- nance of such projects. case study in industry, industrial practice, expert opinion, observation


";Evaluation research;Architecture Smells;Yes;Yes, after each release using a proprietary method. ;general:# approuch: ' Architecture Smell'#tools: 'Arcan';Yes, using a proprietary formula to calculate the tim effort to fix the architecture smell;Yes. identify, measure, prioritize, repayment, monitoring;;;problem characterization: yes, bibliographic review: yes, data collection: yes, hypothesis: no, experimentation: yes, results: yes, final: good;Great;;;Complete
38;Cai and Kazman 2016;3;2016;Yuanfang Cai, Rick Kazman;Software Architecture Health Monitor;2016;In this paper, we first discuss the concept of architecture debt and how this debt grows in virtually every software-intensive project. Next we propose a methodology for developers to monitor the health of a project’s architecture through an analysis of the development artifacts that a project produces. Our objective is to monitor and manage architecture debt by leveraging an architecture model that we proposed recently, called the Design Rule Space (DRSpace). We use DRSpaces to split a complex system into smaller subsystems based on features, patterns, refactoring targets, etc., so that we can monitor and analyze the evolution and interaction of each subsystem separately. We also employ a recently proposed architectural metric—Decoupling Level—to quantitatively monitor changes in a project’s overall level of architecture maintainability. Using these tools, we describe our vision for a software architecture “health monitor”, on analogy with a health monitor used in a hospital, to continuously monitor the health of the “patient” and alert staff to any potential danger signs ;Workshop;Proceedings of the 1st International Workshop on Bringing Architectural Design Thinking into Developers' Daily Activities;International Workshop on Bringing Architectural Design Thinking;Architecture Design Thinking;Software architecture health monitor;4;"In this paper, we first discuss the concept of architecture debt and how this debt grows in virtually every software-intensive project. Next we propose a methodology for developers to monitor the health of a project’s architecture through an analysis of the development artifacts that a project produces. Our objective is to monitor and manage architecture debt by leveraging an architecture model that we proposed recently, called the Design Rule Space (DRSpace). We use DRSpaces to split a complex system into smaller subsystems based on features, patterns, refactoring targets, etc., so that we can monitor and analyze the evolution and interaction of each subsystem separately. We also employ a recently proposed architectural metric—Decoupling Level—to quantitatively monitor changes in a project’s overall level of architecture maintainability. 
";Yes;No;Yes;Yes;Empirical study;Pesquisa aplicada que visa desenvolver uma abordagem para medir débito arquitetural usando o método DRSpace A validação dessa abordagem foi feita através da validação em um projeto Open Source, no caso o Hadoop HDFS. Empirical study on Hadoop Apache Project;Validation Research;Architecture Smells;Architectural Root;Tracking architecture roots, architecutre flaws and Decopling Level for each version analysed by Titan tool;general: # approuch: architecture smells, Decopling Level, DRSpace, Propagation Cost, DSM# tools: 'Titan';Yes, using a proprietary formula to calculate the effort to fix the architecture smell;Yes. identify, measure, monitoring;;;problem characterization: yes, bibliographic review: yes, data collection: yes, hypothesis: no, experimentation: yes, results: yes, final: regular;Strong;;;Complete
48;Kazman et al. 2015;118;2015;Rick Kazman, Yuanfang Cai, Ran Mo, Qiong Feng, Lu Xiao, Serge Haziyev, Volodymyr Fedak, Andriy Shapochka;A Case Study in Locating the Architectural Roots of Technical Debt;2015;Our recent research has shown that, in large-scale software systems, defective files seldom exist alone. They are usually architecturally connected, and their architectural structures exhibit significant design flaws which propagate bugginess among files. We call these flawed structures the architecture roots, a type of technical debt that incurs high maintenance penalties. Removing the architecture roots of bugginess requires refactoring, but the benefits of refactoring have historically been difficult for architects to quantify or justify. In this paper, we present a case study of identifying and quantifying such architecture debts in a large-scale industrial software project. Our approach is to model and analyze software architecture as a set of design rule spaces (DRSpaces). Using data extracted from the project's development artifacts, we were able to identify the files implicated in architecture flaws and suggest refactorings based on removing these flaws. Then we built economic models of the before and (predicted) after states, which gave the organization confidence that doing the refactorings made business sense, in terms of a handsome return on investment.;Conference;"2015 IEEE/ACM 37th IEEE International Conference on Software Engineering  ICSE 2015, Florence, Italy Software Engineering in Practice 
";"International Conference on Software Engineering  ";Software engineering;Computer architecture,Software engineering,Business,History,Sonar detection,Microprocessors;10;"To remedy this situation we have applied following strategy to identify and quantify architecture debts to a system that SoftServe was maintaining, and justified the refactoring of architecture problems with an economic analysis. We first used the Design Rule Space (DRSpace) analysis approach [30] to precisely locate architecture debts in a few clusters of files. After that, we visualized the architecture flaws among these files, pointing out to the architects how these flaws propagate errors. After these flaws, (architecture hotspots), were confirmed by the architects, we extracted data from the development process to quantify the penalty these debts were incurring, estimated the potential benefits of refactoring, and made a business case to justify refactoring. 
When we started working together SoftServe had already been maintaining their system, which they inherited from another company, for almost two years. They were actively trying to improve the maintainability of the code base, remove dead and cloned code, and rationalize its architecture, and they had already made some progress in this direction. They had been working with commercial tools, such as SonarQube1, Understand2 and Structure 1013, to help identify problematic areas in the system. What the DRSpace process offered them was, however, quite different than those commercial tools: we offered them explicit (and automated) identification of problem areas in the architecture, along with explanations for why these areas were problematic. Unlike other tools that report a list of individual problematic files, We reported these architecture debts in the form of 3 to 6 groups of architecturally related files, and the architecture flaws among them can be visualized. This analysis revealed significant architecture issues not detectable by other tools, and allowed them to plan refactoring strategies to address these problems 
We conducted a case study as a means of achieving two objectives. First, we wanted to understand if our architecture hotspot analysis process could identify problems—architecture debts—that industrial practitioners consider to be real, signif- icant, and worth fixing. Second, we wanted to understand if it is possible quantify these architecture debts, based on readily available project data, to help these practitioners make rational refactoring decisions. 

RQ1: According to opinions of SoftServe’s architects, are the set of architectural issues that we reported truly problematic issues—that is, architecture debts? 
RQ2: How do the results returned by the Titan tool chain differ from the files reported as sources of technical debt by other tools SoftServe is using, such as SonarQube? 
RQ3: Is it possible to quantify the return on investment of removing architecture debts? In other words, is it possible to determine the penalty incurred by the debts and the expected benefits if the debts are removed, and compare this with the costs of refactoring? ";Yes;Yes;No;Yes;Case study;"In this paper we present a case study of a software development organization–SoftServe Inc.—that did just that: facing high and mounting problems with technical debt in a project, they were able to analyze their software architecture, pinpoint the hotspots within that architecture that were the principle causes of technical debt, propose refactoring solutions to fix the hotspots, and (perhaps most important) make a business case for the refactoring. In this paper, we will describe the architectural analysis that we did for one of the projects, and how we helped them build their business case. case study in industry, industrial practice, expert opinion, observation, empirical study in industry
";Evaluation research;System-level structure quality issues;Hotspot. Calculate a hotspot to detect problematic files and architecture debts, in terms of timelines and efficiency.;The approach of DRSpace is performed for each release analysed by software architecture to verify and confirm the architecture debt and effort is calculated in person per month.;" general:""hotspot, refactoring, source code, revision history, architectural issue, issue tracker, issue list, file dependencies, specialist evaluation, business cases, Unstable Interface, Implicit Cross-module Dependency, modularity violations, Unhealthy Inheritance Hierarchy""
 # 
 approuch:""DRSpace, Design Ruel Hierarchy, Design Structure Matrix, Architecture Roots""
 #
 tools:""Titan, SonarQube, Understand, Jira, Git""";"The Architectural Debt was quantified using Technical Debt Calculation framework proposed by authors.  The effort about ATD is calculated based on number of defects and number of lines of changes.   The effort of refactoring and ROI (Return of Investiment is calculate based on PM (Person per month) via Software Architecture and Project Management of the studied project. Thus, it is necessary a specialist analysis to calculate the principal of Architectural Technical Debt.";;The authors proposed an approuch to identify, measure, calculate the ATDI via case study in a large IT company analysing a sequence of versions via Dspace method;The case study performed only one company in only one system.;problem characterization: yes, bibliographic review: yes, data collection: yes, hypothesis: yes, experimentation: yes, results: yes, final: great;Great. due to the authors proposed a methdo to identify, measure and calculate the ATDI using DRSpace based on analysis of a sequency of version from a software in a real case study in a large IT company.;The case study performed only one company in only one system.;Our future work consists of a longitudinal study wherein we do four things: First, we will track the architectural integrity of this system on a regular basis. That is, we plan to analyze periodic snapshots of SoftServe’s system, to see whether the refactoring is being done correctly, and whether it is eroding over time. Second, we plan to continue to track the frequency of reported defects, and their connection to the files in SS1. Third we plan to continue to track the frequency of changes to the files of SS1. Finally, we plan to track the lines of code committed to fix defects and to make changes. This longitudinal data capture and analysis will allow us to validate the expectations and opinions collected in the present study, and to build better predictive models for SoftServe in the future. We are also in the process of conducting other industrial case studies, to show the repeatability of our methods in different industrial contexts.;Complete
47;Martini and Bosch 2015;25;2015;Antonio Martini, Jan Bosch;Towards Prioritizing Architecture Technical Debt: Information Needs of Architects and Product Owners ;2015;Architectural Technical Debt is a metaphor for representing sub-optimal architectural solutions that might cause an interest, in terms of effort or quality, to be paid by the organization in the long run. Such metaphor has been regarded as useful for communicating risks of suboptimal solutions between technical and non-technical stakeholders. However, it's fundamental to understand the information needs of the involved stakeholders in order to produce technical debt measurements that would allow proper communication and informed prioritization. We have investigated, through a combination of interviews, observation and a survey, what key information is needed by agile product proprietarys and software architects in order to prioritize the refactoring of risky architectural technical debt items with respect to feature development. ;Conference;2015 41st Euromicro Conference on Software Engineering and Advanced Applications;Euromicro Conference on Software Engineering and Advanced Applications;Software Engineering and Advanced Applications;Architecture Technical Debt,Prioritization Aspects,Feature Prioritization,Refactoring Prioritization,Information Need;8;"According to a recent study carried out by the same authors of this paper [6], the prioritization of ATD with respect to feature development is an important activity in order to balance the short-term value delivery and the long-term responsiveness of a company. Not prioritizing ATD might lead to software development crisis followed by big refactoring activities preventing the continuous delivery of features [6]. Although such prioritization seems a critical activity, the recent mapping study found a gap in the current scientific knowledge: “More industrial studies are needed to show how to prioritize a list of TD items to maximize the benefit of a software project and which factors should be considered during TD prioritization in the context of commercial software development.” [3]. We therefore intend to fill such gap by exploring how the prioritization activity is performed and what are the information needs between the key actors in such activity: the software architects and the product proprietarys (POs). We especially investigated large Scandinavian companies developing embedded software and employing Agile software development. Our research questions are the following: 
RQ1: What is the information needed by product proprietarys and architects to prioritize ATD with respect to feature development? 
RQ2: What are the differences between architects and product proprietarys when prioritizing ATD with respect to features? ";Yes;Yes;No;Yes;Case study;"We have employed a multiple case study involving 6 cases in 4 large companies. We have interviewed four kinds of roles, software, system architects, product proprietarys responsible for single products and for portfolios. In order to shed light on what is the important information needed to prioritize ATD, we have collected different kinds of data, by qualitatively observing the prioritization activity and by collecting quantitative data from the participants with a questionnaire. case study in industry, industrial practice, expert opinion, observation, empirical study in industry
";Evaluation research;Architectural compliance issues;No;No;"general:""Rank of Priorization, refactoring, catalog of ATD Effects, Taxonomy of ATD, Contagious ATD, code change, code churn, complexity, issue tracker""
 # 
 approuch:""multiple case study""
 #
 tools:""questionaries""";No;;The authors showed a list of important aspects regarding to ATD causes such as Double effort, Big delivers, Code changes, complement tests, quality issues, hidden TD, Wrong estimation, Contagius ATD, Developer idling;There is no identification of ATD itens;problem characterization: yes, bibliographic review: yes, data collection: yes, hypothesis: no, experimentation: no, results: yes, final: regular;Good. due to the authors showed a list of important aspects regarding to ATD causes such as Double effort, Big delivers, Code changes, complement tests, quality issues, hidden TD, Wrong estimation, Contagius ATD, Developer idling;The most important limitation is the limited sample size of the respondents. However, we aimed at reporting the understanding from a case study, which included both qualitative and quantitative data, rather than surveying a large number of practitioners. Furthermore, as previously explained, we offer a novel understanding of an important and overlooked research subject. The authors aim at collecting such evidence, using an investigation tool improved with the help of the exploratory results obtained from the study presented here.;The next step, already in the authors’ plan, consists of conducting a version of this investigation involving a large sample of respondents from a large set of companies, in order to further strengthen the current case study-specific findings with a broad, quantitative investigation. Another important next step is to analyze the customer-related information used during the prioritization activity in order to understand how they are compared to the ATD effects in order to prioritize ATD refactoring against feature development.;Complete
20;Tommasel 2019;2;2019;"Antonela Tommasel 
";Applying Social Network Analysis Techniques to Architectural Smell Prediction ;2019;As a software system evolves, the amount and complexity of the interactions amongst its components is likely to increase, which negatively affects the system design structure and also its quality. For instance, certain modules might become coupled due to a new user feature being added or to sub- optimal development decisions. Design degradation symptoms are often related to high coupling and unwanted dependencies, such as: cyclic dependencies or violations to design rules, amongst other architectural smells. Thus, the early detection of such symptoms is important for architects to: i) anticipate dependency- related design problems in different parts of the system, ii) assess possible situations of technical debt, and iii) proactively look for solutions to preserve the quality of the system. Although there are approaches that analyse design dependencies in code bases and flag smell occurrences, very few of them have dealt with the prediction of dependency relations amongst software compon- ents. This research hypothesises that a predictive approach can warn architects about dependency-related problems before they appear. To this end, a particular graph-based approach is social networks analysis (SNA), which has been used for modelling both nature and human phenomena. Specifically, SNA techniques can predict links that do not yet exist between pairs of nodes in a network. SNA applications have shown evidence that the topological features of dependency graphs can reveal interesting properties of the software system under analysis. Nonetheless, SNA techniques have not yet been extensively exploited in the Software Architecture community. In this context, the question that motivates this research is to what extent SNA can leverage on information from a software design (and its evolution over time) for inferring new dependencies and likely configurations of architectural smells out of those dependencies. ;Conference;2019 IEEE International Conference on Software Architecture Companion (ICSA-C);International Conference on Software Architecture Companion (ICSA-C);Software Architecture;"Measurement,Social networking online,Computer architecture,Software architecture,Software systems,Software design
";8;"In order to make predictions about software design depend- encies, a particular graph-based approach is Social Networks Analysis (SNA), which refers to a strategy for analysing social structures through network and graph theories [16]. SNA studies to what extent the evolution of a network can be modelled by using features intrinsic to the network [16]. One particular task is known as Link Prediction (LP), and aims at inferring missing links between two nodes in a network based on the observable interactions (or links) amongst nodes and node attributes, when available. Due to its relevance in different domains, several techniques have been proposed to solve the LP problem, usually based on graph structural features that assess similarity between pairs of nodes. As software architectures comprise components that interact with each other, it is natural to model architectures as graphs. In fact, a module view can be modelled as a dependency graph, in which nodes represent modules and directed edges represent usage relations. These relations can be inferred from the code via static analysis. However, software design networks could have a different dynamic from traditional social networks. 
The motivations for this research come from the lack of studies investigating the potential of SNA not only for describing software design structures, but also for predicting their evolution or properties. The analysis then would not just be limited to characterising design elements (e.g. packages, components) and their dependencies, but to how design in- formation can be used to provide insights about future system versions. This knowledge would support predictive capabilities for architects’ decisions regarding system refactorings or other strategies for dealing with technical debt in the system. In this context, the goal of this research is to use SNA techniques along with information from current and past design structures of a system for inferring possible architectural smells in terms of configurations of design dependencies. 
RQ1. How do architectural smells evolve over system versions, in terms of increasing or decreasing their de- pendency configurations? 
RQ2. What criteria are useful for assessing similarity of design elements with respect to link prediction? 
RQ3. Can past system versions affect, and improve the predictions of, the design structure of a future version? 
RQ4. To what extent Machine Learning techniques can aid in the prediction of architectural smells? ";Yes;No;Yes;Yes;Empirical study;Conceptual approach based on apache java open-source project;Validation Research;Architecture Smells;It was defined a SNA (Socia Network Analysis) metric to identify the architectural smells. ;Yes, after each release using a proprietary method. ;"general:""Architectural Smells, Social Network, maintainability,Social Network Analysis, link prediction, source code, revision history,  dependency prediction, time series, cycle, hub-like, unstable dependency, ranking-based link prediction, machine learning prediction""
 # 
 approuch:""Machine Learning, prediction of architectural smells, Dependency Graph Representation, predictive approach""
 #
 tools:""dependency-analyser, proprietary tool, weka""";No;;The author proposed a approuch to discover parts the software that has arquitectural smells using code analysis and code smells detection throught the versions of the software. Besides there is a replication kit available on github ( https://github.com/tommantonela/icsa- 2018) to reproduce the study.;The authro used a tool that analysis only java source code. There is no method to calculate the ATD cost.;problem characterization: yes, bibliographic review: yes, data collection: yes, hypothesis: yes, experimentation: no, results: yes, final: good;Good. due to show an approuch to identify ATD via architecture smells using code analysis and it is possible to monitore the evolution of version regard to architecture smells;The authro used a tool that analysis only java source code. There is no method to calculate the ATD cost.;Once the prediction technique is fully evaluated, it will be incorporated into a tool to evaluate the capabilities of the approach in a study with subjects in the context of real software projects. Finally, it is expected to include other types of architectural smells [15] in the work.;Complete
33;Nord et al. 2012;154;2012;Robert L. Nord, Ipek Ozkaya, Philippe Kruchten, Marco Gonzalez-Rojas;"In Search of a Metric for Managing Architectural Technical Debt 
";2012;Practices designed to expedite the delivery of stakeholder value can paradoxically lead to unexpected rework costs that ultimately degrade the flow of value over time. This is especially observable when features are developed based on immediate value, while dependencies that may slow down future development efforts are neglected. The technical debt metaphor conceptualizes this tradeoff between short-term and long-term value: taking shortcuts to optimize the delivery of features in the short term incurs debt, analogous to financial debt, that must be paid off later to optimize long-term success. In this paper, we describe taking an architecture-focused and measurement-based approach to develop a metric that assists in strategically managing technical debt. Such an approach can be used to optimize the cost of development over time while continuing to deliver value to the customer. We demonstrate our approach by describing its application to an ongoing system development effort.;Conference;2012 Joint Working IEEE/IFIP Conference on Software Architecture and European Conference on Software Architecture;Conference on Software Architecture and European Conference on Software Architecture;Software Architecture;technical debt,software architecture,software economics,cost of rework,total cost of proprietaryship;10;"In this paper we’ll endeavor to provide a foundation for incurring and managing prudent, deliberate, intentional technical debt.  We use software architecture as a means to identify and monitor architectural technical debt, or architectural debt, so that re-architecting and refactoring decisions can be made in a timely manner. We illustrate our approach by describing an ongoing development effort: the Disaster Response Network-Enabled Platform (DRNEP). ";Yes;Yes;No;Yes;Case study;"Case study of The Disaster Response Network-Enabled Platform (DRNEP) is a system that integrates a set of independently developed infrastructure and disaster simulators. 

To compare Architecture Debt Analysis between two paths: 
Path #1: Deliver soon 
Path #2: Reduce rework and enable compatibility 

.case study in industry, industrial practice, expert opinion, observation, empirical study in industry
";Evaluation research;Architectural compliance issues;ATD based in Software Architecture estimation in hours;Yes, after each release using a proprietary method. ;" general:""specialist evaluation, package, release plan, dependency analysis, DSM, implementation cost, propagation cost, rework cost, use cases, refactoring, re-architecting, person effort, modularity metrics, change propagation metric""
 # 
 approuch:""proprietary formulas, design structure matrix""
 #
 tools:""proprietary tool""";"The cost to pay ATDI is estimated in hours according a formula proposed by authros.
The Total Cost T of release n is a function of the implementation and rework costs, Ci and Cr : 
T F(Ci,Cr)";;The authors conducted a case study in a real large anc complex system of natural disaster to evaluate each release regarding ATD and calculate the effort to fix them.;There is not list of ATDI for each relase analysed in case study.;problem characterization: yes, bibliographic review: yes, data collection: yes, hypothesis: no, experimentation: no, results: yes, final: good;Great. due to the authors proposed a way to identify ATD during software evolution and calculate the cost of ATD according software architecture components created or edited.;There is no the list of ATDI for each release. The paper only show the cost estimated for ATD in release, but there is details for each release.;"Feature and architectural element slicing.
Story slicing in agile development involves determining the simplest thing the user can do that is of value, and how that function cuts across the system.
Extensions to the economic model.
We account for debt at the time it is paid in rework cost. For prudent and deliberate debt we plan to extend the economic model to account for the future cost of paying back debt
Managing debt.
This paper’s contribution to the area of technical debt management is its discussion of analysis and visibility of dependencies and their implications for technical debt. Next steps in our research will focus on moving from monitoring to more actively and strategically incorporating technical debt into the architectural design process";Complete
26;Cai and Kazman 2019;2;2019;Yuanfang Cai,  Rick Kazman;DV8: Automated Architecture Analysis Tool Suites ;2019;"Although software measurement and source code analysis techniques have been researched for decades, making project decisions that have significant economic impact—especially decisions about technical debt and refactoring—is still a chal- lenge for management and development teams. Development teams feel the increasing challenges of maintenance as the architecture degrades, and often have intuitions about where the problems are, but have difficulty pinpointing which files are problematic and why. It is still a challenge for the development teams to quantify their projects’ maintenance problems—their debts—as a way of justifying the investment in refactoring. 
Here we present our tool suite called DV81. The objective of DV8 is to measure software modularity, detect architecture anti-patterns as technical debts, quantify the maintenance cost of each instance of an anti-pattern, and enable return on investment analyses of architectural debts. Different from other tools, DV8 integrates data from both source code and revision history. We now elaborate on each of DV8’s capabilities. ";Conference;2019 IEEE/ACM International Conference on Technical Debt (TechDebt) ;International Conference on Technical Debt (TechDebt) ;Technical Debt;"Software Architecture, Software Quality, Software Maintenance 
";2;"Present a tool called DV8 and theirs features. The objective of DV8 is to measure software modularity, detect architecture anti-patterns as technical debts, quantify the maintenance cost of each instance of an anti-pattern, and enable return on investment analyses of architectural debts. Different from other tools, DV8 integrates data from both source code and revision history. We now elaborate on each of DV8’s capabilities. 
";No;No;No;No;Tool evaluation;Apresentação de ferramenta, características e levantamento de locais que já usaram a ferramenta.;Solution proposal;Not specified;No;No;No;No;;The objective of DV8 is to measure software modularity, detect architecture anti-patterns as technical debts, quantify the maintenance cost of each instance of an anti-pattern, and enable return on investment analyses of architectural debts. Different from other tools, DV8 integrates data from both source code and revision history;"Weak. The paper is more technical and describe a tool called DV8 and its importance to check the software architecture. However, it is not a scientific study.
";"problem characterization: yes, bibliographic review: no, data collection: no, hypothesis: no, experimentation: no, results: no, final: Weak,extra:Weak. Actually, this is a technical paper with only two pages, and there is no scientific rigor.
";Weak. but the tool is useful to check important problems from software architecture such as measure software modularity, detect architecture anti-patern and quantify the maintenance cost.;The paper has only two pages.;No;Complete
28;Skiada et al. 2018;5;2018;Peggy Skiada, Apostolos Ampatzoglou, Elvira-Maria Arvanitou, Alexander Chatzigeorgiou, Ioannis Stamelos;Exploring the Relationship between Software Modularity and Technical Debt ;2018;Modularity is one of the key principles of software design. In order for a software system to be modular, it should be organized into modules that are highly coherent internally, whereas at the same time as independent from other modules as possible. In this paper we explore coupling and cohesion metrics at the software package level—i.e., one of most basic levels of software functional decomposition in object-oriented (OO) sys- tems, with the aim of investigating their relation to the technical debt of each package. Current state-of-the-art tools in TD meas- urement are working on the source code level, and the extent to which they can unveil limitations at the architecture level (e.g., violations of the modularity principle), has not been explored so far. To achieve this goal, we conducted a case study on 1,200 packages retrieved from 20 well-known open source software projects. The results of the study suggested that current measures of technical debt are able to identify / predict modules that lack modularity, and therefore suffer from Architectural Technical Debt (ATD). The results of the study are discussed both from the practitioners’ and researchers’ point of view. ;Conference;2018 44th Euromicro Conference on Software Engineering and Advanced Applications ;Euromicro Conference on Software Engineering and Advanced Applications ;Software Engineering;coupling, cohesion, modularity, technical debt ;4;"In this study, we investigate the relation between package-level modularity metrics and technical debt principal, as measured by a state-of-the-art tool, namely SonarQube that is based on the SQALE model [11]. SonarQube is an Open Source Software (OSS) platform for the continuous inspection of code quality. SonarQube assesses the technical debt of a software system at the source code level by counting violations of best practices (e.g., Removal of Unused Private Fields, Constructors Should be Used for String Initialization, or @Override Should be Used for Overriding Methods) and estimating the time needed to resolve them. The platform supports a plethora of programming languages and it can offer detailed reports re- garding duplicated code, coding standards, unit tests etc. Nevertheless, based on the current TD calculation model it is not clear if the violations that SonarQube can capture are also (di- rectly or indirectly) related to architecture violations, or at least, if the provided measure is correlated with violation of some architecture best practices (e.g. modularity). 

The main research question of this paper is: “Is TD principal as quantified by SonarQube related to the lack of software modularity?

RQ1: Is TD principal related to package cohesion? 
RQ2: Is TD principal related to package coupling?";Yes;No;Yes;Yes;Empirical study;"To achieve this goal we have performed a large-scale empirical study on more than 1,000 packages written in Java and explored the aforementioned relationship. 
";Validation Research;System-level structure quality issues;Package modularity via Sonarqube using TD Index from cohesion and coupling.;No;" general:""modularity, package dependencies, design flaws, package cohesion, package coupling, source code, revision history, Average Coupling Afferent, Total Coupling Intensity between Packages, Cohesion among Package Classes""
 # 
 approuch:""Correlation analysis""
 #
 tools:""SonarQube""";No;;The study selected popular open projects that is available. the proposed metrics are simple to calculate. the proposed correlation is easy to understand;The study shoud be provide a repliaction kit;problem characterization: yes, bibliographic review: yes, data collection: yes, hypothesis: yes, experimentation: yes, results: yes, final: good;good.;There is no ADTM process, there is no how to calculate ATD cust;No;Complete
31;Eliasson et al. 2015;20;2015;Ulf Eliasson, Antonio Martini, Robert Kaufmann, Sam Odeh;Identifying and Visualizing Architectural Debt and Its Efficiency Interest in the Automotive Domain: A Case Study;2015;Architectural Technical Debt has recently received the attention of the scientific community, as a suitable metaphor for describing sub-optimal architectural solutions having short- term benefits but causing a long-term negative impact. We study such phenomenon in the context of Volvo Car Group, where the development of modern cars includes complex systems with me- chanical components, electronics and software working together in a complicated network to perform an increasing number of functions and meet the demands of many customers. This puts high requirements on having an architecture and design that can handle these demands. Therefore, it is of utmost importance to manage Architecture Technical Debt, in order to make sure that the advantages of sub-optimal solutions do not lead to the payment of a large interest. We conducted a case study at Volvo Car Group and we discovered that architectural violations in the detailed design had an impact on the efficiency of the communication between components, which is an essential quality in cars and other embedded systems. Such interest is not studied in literature, which usually focuses on the maintainability aspects of Technical Debt. To explore how this Architectural Technical Debt and its interest could be communicated to stakeholders, we developed a visual tool. We found that not only was the Architectural Debt highly interesting for the architects and other stakeholders at VCG, but the proposed visualization was useful in increasing the awareness of the impact that Architectural Technical Debt had on efficiency. ;Workshop;2015 IEEE 7th International Workshop on Managing Technical Debt (MTD);International Workshop on Managing Technical Debt (MTD);Technical Debt;"Software
Visualization,
Computer architecture,
Stakeholders,
Context,
Automotive engineering,
Complex systems";8;"It is identify ATD in Architectural high level view and visualise ATD interest based on performance effort of intercommunication components in a Automotive Industry that use ECU (Eletronic Component Unit) to control automotive components. 

According to a recent mapping study [7], ATD is studied to some extent in literature, but there are still several gaps when practically managing such kind of debt: the interest (impact) often remains hidden, which makes it difficult for the stakeholders to decide if the refactoring of ATD should be performed or not. Many studies focus on the maintainability impact that an ATD item has, but not on other quality attributes, such as performance. 
Another gap is that ATD is studied at a rather general level, but there is a lack of empirical studies showing what ATD is and how it is managed in different contexts, for example in the automotive industry. 
Finally, there is little research about how to visualize ATD and its interest (impact), especially in a combined view. 
Based on the previous gaps, we have constructed the fol- lowing three research questions: 
RQ1  What is a typical ATD item for the automotive industry? 

RQ2  What is the impact, or interest, of such ATD item? 

RQ3  How can the ATD and its interest be visualized 
together to aid the stakeholders’ awareness? 

In this study, we have explored how to visualize the effi- ciency interest caused by architectural violations in a concrete case. We have identified, together with the architects at VCG, relevant ATD items present at the design level but forbidden at the architecture level. Then we have investigated the interest in terms of efficiency (a key quality for cars) due to the existence of such ATD items. We have constructed a visualization tool based on the literature state of the art and the ATD, and we have validated the tool and visualization with architects at the company. ";Yes;Yes;No;Yes;case study;"To answer the research questions presented in Section I, we conducted an exploratory case-study [12] at the electrical development department at VCG. The study was divided into the following four steps. exploratory case study in industry, industrial practice, expert opinion, observation, empirical study in industry
";Evaluation research;Violations of good architectural practices;Misplaced LC interest based on scale of weight proposed by the authors. ;For each architecture planning to create or maintain the LC (Logical Components);" general:""maintainability, performance, visualization of ATD, logical view, design view, deployment, efficiency, component communication, component dependencies, Eletronic Control Unit, Automotive Domain""
 # 
 approuch:""semi-structured interview, cost of component communcation, proprietary formulas, treemap""
 #
 tools:""proprietary tool to visualize dependency among components""";Misplaced LC interest based on scale of weight proposed by the authors. ;;The study was performed in a real case industry application;There is no repliaction kit to reproduce the study;problem characterization: yes, bibliographic review: yes, data collection: yes, hypothesis: yes, experimentation: yes, results: yes, final: good;Good. In this paper, we present a novel approach for visualizing the debt and the interest together. Such visualization helps the stakeholders identifying and prioritizing ATD, by under- standing the impact of different ATD items (specifically non- allowed dependencies) on efficiency. The validation interviews with the stakeholders at VCG confirmed that such tool would be valuable for architects and other stakeholders. It is important for calculate the performance communication between the components in a automotive domain, but can be used in a network distributed system such as a microservice system.;Since there is only one studied system, the resulting method- ology is entirely based on such studied case and could there- fore potentially be limited to similarly designed architectures, e.g. where an intended architecture is realized as logical components deployed to ECUs.;In the future we plan to continue our research on what other ATD items can be found and what other impact measures can be combined together for having the complete picture of ATD and its interest, which would greatly help the decision making of the main stakeholders. We also plan to investigate the reasoning behind the architectural violations, whatever they are intentional or not, and whatever or which the architectural violations benefit the final product. Finally, stakeholders that were part of the early evaluation of the tool said that it would be valuable to see the evolution of the debt. They wanted to see if the tendency is that the debt increases or decreases over time, as well as see what impact planned or potential future changes would have.;Complete
44;Fontana et al. 2016;23;2016;Francesca Arcelli Fontana, Riccardo Roveda, Marco Zanoni ;"Technical Debt Indexes provided by tools: a preliminary discussion 
";2016;In software maintenance and evolution, it is important to assess both code and architecture in order to identify issues to be solved to improve software quality. Different tools provide some kind of index giving us an overall evaluation of a project to be used when managing its technical debt. In this paper, we outline how the indexes, that we call in general Technical Debt Indexes, provided by five different tools are computed. We describe their principal features and differences, what aspects they are missing, and we outline if (and how) the indexes take into account architectural problems that could have a major impact on the architectural debt. We show that the indexes rely on different information sources and measure different quantities.;Workshop;2016 IEEE 8th International Workshop on Managing Technical Debt (MTD);International Workshop on Managing Technical Debt (MTD);Technical Debt;"Technical Debt Indexes,
Architectural Debt,
Software Quality Analysis Tools";4;"It is evaluate 5 tools to check Technical Debt Index generated by the each tool.

Technical Debt/Severity, Deficit Index, that offers an evaluation of the overall quality of an analyzed project. In the paper, with the term Technical Debt Index (TDI), we refer to any kind of quality index computed by the tools. These indexes are derived in different ways and take into account different features. We focus our attention on the TDI provided by known tools, with the aim to understand what exactly each index takes into account, what the value of the index represents, and its completeness w.r.t. the information that can be exploited to estimate Technical Debt. With these aims, we try to answer the following questions: 

Q1  How are the quality indexes the tools provide exactly computed? Which features do they take into account? 
Q2  Which index does take more into account the architectural issues and in which way? 
Q3  Which are the features not provided or taken into account by the indexes? 
We decided to consider in this paper five tools that provide some kind of TDI: CAST, inFusion, Sonargraph, SonarQube and Structure101. ";No;No;No;No;Tool evaluation;Evaluation of tools and methods applied by tools about TDI.;Philosophycal paper;Not specified;No;No;" general:""Architecture Smells, Design Metrics, Code Metrics, Architecture Violations, Resolution cost, Keeping cost, unity measure (money, time, rank, loc)""
 # 
 approuch:""Tools evaluation""
 #
 tools:""Cast , InFusion,   SonarGraph,  SonarQube   Structure101""";No;;It was collected five tools to check TD index about ATD. It was observed how to calculate de TD index and the unit measure.;There is no data collected to compare the used tools. There is no Design research and there is no an experiment to evaluate the tools using a set of data.;problem characterization: yes, bibliographic review: yes, data collection: yes, hypothesis: no, experimentation: no, results: yes, final: regular;good.;The study should be created an experimentation using real systems to compare each tool evaluated.;We plan to investigate the role of code and architectural smells in TD, since they are associated to known solutions, that can speed up their resolution process. We would like also to work on the definition of a new TDI, with a focus on code and architectural debt, and experiment it on a large dataset of projects. In the TDI computation we would like to consider: 1) Code and Architectural smells detection. 2) Code and architecture/design metrics. 3) History of a system, including code changes and lifespan of smells. 4) Identification of problems more critical than others, to weight the collected analysis elements (e.g., metrics, smells, issues) according to their relevance in existing (past) projects.;Complete
43;MacComark and Sturteant 2016;35;2016;Alan MacCormack, Daniel J. Sturtevant ;Technical debt and system architecture: The impact of coupling on defect-related activity ;2016;"Technical Debt is created when design decisions that are expedient in the short term increase the costs of maintaining and adapting this system in future. An important component of technical debt relates to decisions about system architecture. As systems grow and evolve, their architectures can degrade, increas- ing maintenance costs and reducing developer productivity. This raises the question if and when it might be appropriate to redesign (“refactor”) a system, to reduce what has been called “architectural debt”. Unfortunately, we lack robust data by which to evaluate the relationship between architectural design choices and system maintenance costs, and hence to predict the value that might be released through such refactoring efforts. 
We address this gap by analyzing the relationship between system architecture and maintenance costs for two software systems of similar size, but with very different structures. one has a “Hierarchical” de- sign, the other has a “Core-Periphery” design. We measure the level of system coupling for the 20,000+ components in each system, and use these measures to predict maintenance efforts, or “defect-related ac- tivity.” We show that in both systems, the tightly-coupled Core or Central components cost significantly more to maintain then loosely-coupled Peripheral components. In essence, a small number of compo- nents generate a large proportion of system costs. However, we find major differences in the potential benefits available from refactoring these systems, related to their differing designs. Our results generate insight into how architectural debt can be assessed by understanding patterns of coupling among com- ponents in a system. ";Journal;The Journal of Systems and Software;Journal of Systems and Software;System Architecture;Technical Debt, Software Architeture;13;"Evaluate two systems with different architectural structure comporting the coupling among components about defect related activity.

We address this gap by analyzing the relationship between system architecture and maintenance costs for two software systems of similar size, but with very different structures. one has a “Hierarchical” de- sign, the other has a “Core-Periphery” design. We measure the level of system coupling for the 20,000+ components in each system, and use these measures to predict maintenance efforts, or “defect-related ac- tivity.” We show that in both systems, the tightly-coupled Core or Central components cost significantly more to maintain then loosely-coupled Peripheral components. In essence, a small number of compo- nents generate a large proportion of system costs. However, we find major differences in the potential benefits available from refactoring these systems, related to their differing designs. 
";Yes;Yes;No;Yes;Empirical study;Empirical Study of two different systems created in C/C++ with two different architecturee. The first in a Hierarchical Architecture and the Second as a Core-Perifphery Architeture.;Evaluation research;System-level structure quality issues;Complexity, coupling and cyclical dependencies  using DSM (Dependent Structure Matrix). The time spends on maintenance.;No;" general:""complexity, modularity, maintanance cost, refactoring, coupling, cohesion, dependencies between components, DSM, source code, issue track, bug tracking, defect-related activity, file changes, specialist evaluation, refactoring, design decisions, code churn, cicly dependencies""
 # 
 approuch:""design structure matrices""
 #
 tools:""proprietary tool""";The cust was based on the time spends on maintanance record in issue tracker. The authors defined a standard cost of U$ 100 per hour to calculate the cust of activity.;;The authors studied a real case for three years and collect data from two large systems about effort and spend the maintenance. The authors analyzed the SVC repository, the bug tracker related to commits, the files changes, and refactoring propagation cust to maintain the systems.;The dataset was not available to reproduce the study.;problem characterization: yes, bibliographic review: yes, data collection: yes, hypothesis: no, experimentation: yes, results: yes, final: good;good. due to The authors studied a real case for three years and collect data from two large systems about effort and spend the maintenance. The authors analyzed the SVC repository, the bug tracker related to commits, the files changes, and refactoring propagation cust to maintain the systems.;The study did not explain the architectural debt used to refactoring in architectural system maintenance. We examine only two systems, albeit with very different designs and from two different firms. We cannot be sure that the findings would apply to other firms or sys- tems. ;Our study generates a number of avenues for future work. First, it provides a benchmark for future studies that seek to examine the relationship between measures of architecture and the costs associated with maintenance and adaptation. Second, it provides methods for evaluating the technical debt associated with software architecture, which could be verified via future empirical studies across a larger number of contexts and systems. Finally, while we focus only on the costs associated with corrective maintenance, a significant amount of the value from refactoring is likely to come from an increase in developer productivity when responding to new requirements. It is our hope that the methods we describe can provide a springboard for undertaking such enquiries.;Complete
51;Sas et al. 2019;6;2019;Darius Sas, Paris Avgeriou, Francesca Arcelli Fontana;Investigating Instability Architectural Smells Evolution: An Exploratory Case Study;2019;Architectural smells may substantially increase maintenance effort and thus require extra attention for potential refactoring. While we currently understand this concept and have identified different types of such smells, we have not yet studied their evolution in depth. This is necessary to inform their prioritisation and refactoring. This study analyses the evolution of individual architectural smell instances over time, and the characteristics that define these instances. Three different types of architectural smells are taken into consideration and mined from a total of 524 versions across 14 different projects. The results show how different smell types differ in multiple aspects, such as their growth rate, the importance of the affected elements over time in the dependency network of the system, and the time each instance affects the system. They also cast valuable insights on what aspects are the most important to consider during prioritisation and refactoring activities. ;Conference;"2019 IEEE International Conference on Software Maintenance and Evolution (ICSME 
";"International Conference on Software Maintenance and Evolution (ICSME)
";Software Maintenance and Evolution;"architectural smells,
technical debt,
architectural technical debt,
cyclic dependencies,
architectural smells evolution";11;In this study, we propose an approach to study the evolution of AS detected by an open source tool named Arcan [5], by tracking individual smell instances and measuring the evolution of the properties of each detected instance. We have detected almost 150.000 unique smell instances in over 500 versions across 14 open source Java projects. We have performed four types of analyses: a generic data mining analysis to have a better understanding of the data, a trend analysis to understand the evolution of the smells over time, a correlation analysis to identify possible correlations among the smell characteristics1 considered, and a survival analysis to document their probability to persist within the system. The focus of this study is on the architectural smells known as instability AS [6]. ;Yes;No;Yes;Yes;Case study;An exploratory case study in 14 different java projects through 524 versions that were analysed detecting architectural smells (Unstable dependency, Hub like dependency and cyclic dependency). It was developed a toolchain that allows to mine architectural smells from pre-complied java systems. Exploratory case study on Apache Projects;Validation Research;Architecture Smells;Architecture Smells;For each release evaluated via ASTracker where tracks smell instances in the projects history.;" general:""architectural smells, refactoring, Hublike dependency, Cyclic dependency, complexity, Unstable dependency, source code, revision history, package analysis, Jaccard similarity index""
 # 
 approuch:""refactoring prioritisation, Goal-Question-Metric, analysis using Qualitas Corpus, Trend evolution classification templates, CORRELATION ANALYSIS""
 #
 tools:""Arcan, ASTracker, GraphML""";No;;The authors studied an evolution process of identifying and tracking architectural smells in corpus qualitas.;The architectural debt index using architectural smells and tracking the index's evolution throughout a system’s history was not precise. for example, the authors should be created a formula to represent the architectural debt index. They were even using a demonstration of evaluation of each architectural smell individually, but a general formula was not created.;problem characterization: yes, bibliographic review: yes, data collection: yes, hypothesis: no, experimentation: yes, results: yes, final: good;good.;The study evaluates only a few projects in java language from Qualitas Corpus. Maybe it does not apply to the industry or other software languages.;As future work, we plan to extend our tooling to mine archi- tectural smells directly from Git repositories, thus allowing us to link the current information to code churn and investigate the effects of smells on change rates.;Complete
52;Fontana et al. 2019;4;2019;Francesca Arcelli Fontana,  Ilaria  Pigazzini,Claudia Raibulet,Stefano Basciano ;PageRank and criticality of architectural smells;2019;Architectural smells represent symptoms of problems at architec- tural level that can negatively impact internal software qualities and lead to architectural debt. Detecting architectural smells and identifying the most critical ones is the key to prioritize refactor- ing efforts and prevent software architecture erosion. In this paper we focus our attention on three architectural smells based on de- pendency issues, called Cyclic Dependency, Unstable Dependency, and Hub-Like Dependency. Moreover, we evaluate the PageRank and Criticality of these smells through the analysis of six projects. PageRank is a measure that estimates whether an architectural smell is located in an important part of the project, where the im- portance is evaluated according to how many parts of a project depend on the one involved in the architectural smell. We describe a case study on the analysis of the possible relation existing between the PageRank and Criticality of the smells. The results show how the two measures can be both used to locate the architectural smells that need particular inspections and attention. ;Conference;ECSA 19: Proceedings of the 13th European Conference on Software Architecture;European Conference on Software Architecture;Software Architecture;"Architectural smells, PageRank, Criticality, Architectural debt, Architecture erosion, Prioritization 
";8;"Hence, in this paper we investigate two measures that can pro- vide a support to the developers/maintainers for the evaluation of the most critical architectural smells. The first one is the criticality associated to each specific type of AS. It is based on the metrics used to detect each smell (described in Section 3.2.2). The second one is called PageRank, evaluated according to each architectural smell instance found in a project. Through the PageRank it is possible to quantify the relevance of the part of the project affected by the smell (see Section 3.2.3). In this way, it is possible to identify the architectural smells which are more central in a project (if many parts depend on the part where the architectural smell is involved) and with a higher impact on the project with respect to those that can be considered more peripheral [16]. 

In this paper, we exploit the Arcan tool [1] to detect three archi- tectural smells (Unstable Dependency, Cyclic Dependency, Hub- Like Dependency) and the Gephi tool1 to evaluate the PageRank of the smells in six projects. We can find cases where the criticality of an architectural smell is evaluated as high, but the PageRank is low, or vice versa. We can find that the PageRank value is significant for a kind of smell, for example for Cyclic Dependency smell, and less for others. 
Hence, through the investigation described in this paper we aim to provide preliminary answers to the following Research Questions (RQ): 
(RQ1) If we consider the PageRank and criticality measures of AS, can we observe the same trends between the values of the two measures for each AS? 
(RQ2) How does the PageRank measure behave in the case a component is affected by different types of AS simultaneously? 
To answer the above questions we analyze and compute in six open source Java projects (Ant, haddop, POI, TOMCAT, FireBugs and JUniti): 
• the architectural smells and their criticality (Section 4.1).
• the PageRank of the architectural smells (Section 4.2).
• the possible relations existing between architectural smell 
criticality and PageRank for RQ1 (Section 4.3.1.).
• the PageRank of the components affected by multiple archi- 
tectural smells for RQ2 (Section 4.3.2) ";Yes;No;Yes;Yes;Case study;Case study in 6 Open Project java ;Validation Research;Architecture Smells;Architecture Smells;No;No;No;;The authros proposed an index to check the criticality of architectural smell using pagerank. The study used a set of open source software projects to extract data about criticality of architectural smells;The is no asses of effort waste to fix Architectural Smell;problem characterization: yes, bibliographic review: yes, data collection: yes, hypothesis: no, experimentation: yes, results: yes, final: good;Good. The authros proposed an index to check the criticality of architectural smell using pagerank.;The is no asses of effort waste to fix Architectural Smell. Besides, there is no monitoring of archicterual smell through the versions analysed;Another future investigation is toward a cross validation of the rank- ing of the architectural smells with the data on the bugs reported in the affected components considering also the historic information of the maintenance activities on the smelly components.;Complete
63;Spinellis and Avgeriou 2019;4;2019;Diomidis Spinellis, Paris Avgeriou ;Evolution of the Unix System Architecture: An Exploratory Case Study  ;2019;Unix has evolved for almost five decades, shaping modern operating systems, key software technologies, and development practices. Studying the evolution of this remarkable system from an architectural perspective can provide insights on how to manage the growth of large, complex, and long-lived software systems. Along main Unix releases leading to the FreeBSD lineage we examine core architectural design decisions, the number of features, and code complexity, based on the analysis of source code, reference documentation, and related publications. We report that the growth in size has been uniform, with some notable outliers, while cyclomatic complexity has been religiously safeguarded. A large number of Unix-defining design decisions were implemented right from the very early beginning, with most of them still playing a major role. Unix continues to evolve from an architectural perspective, but the rate of architectural innovation has slowed down over the system's lifetime. Architectural technical debt has accrued in the forms of functionality duplication and unused facilities, but in terms of cyclomatic complexity it is systematically being paid back through what appears to be a self-correcting process. Some unsung architectural forces that shaped Unix are the emphasis on conventions over rigid enforcement, the drive for portability, a sophisticated ecosystem of other operating systems and development organizations, and the emergence of a federated architecture, often through the adoption of third-party subsystems. These findings have led us to form an initial theory on the architecture evolution of large, complex operating system software.;Journal;EE Transactions on Software Engineering;EE Transactions on Software Engineering;Software Engineering;"Unix, Software Architecture, Software Evolution, Architecture Design Decisions, Operating Systems. 
";31;"In this paper we study the evolution of Unix along the FreeBSD lineage from a software architecture perspective. While there have been studies on how Unix evolved (see Section 2), these have mostly focused at the source code level and were limited to the kernel. On the contrary, we turn our attention to the system architecture and study a) the core architectural design decisions across the main releases, and b) the evolution in the number of the system’s features (obtained from the Unix reference documentation) and in the code’s complexity. The former entails qualita- tive analysis, while the latter quantitative. These analyses subsequently lead to forming an initial theory on the archi- tecture evolution of large and complex operating systems, regarding their form, pace, driving forces, as well as the accumulation of architectural technical debt. 
The goal of this study, stated here using the Goal-Question- Metric (GQM) approach [68], is to “analyze the Unix oper- ating system for the purpose of evaluation and characteri- zation of its architecture evolution with respect to its main architecture design decisions, size and complexity from the point of view of software developers in the context of the Unix ecosystem”. The aforementioned goal can be achieved by answering the following research questions: 
RQ1  What are the main architectural design decisions along the major releases of the system? 

RQ2  How did complexity and the number of features 
evolve along the main releases of the system? 

";Yes;No;Yes;Yes;Case study;Exploratory study;Validation Research;System-level structure quality issues;we study architecture evolution by identifying the major design decisions that were introduced along a number of the most significant releases (see Section 4). Such design decisions are mainly: (a) architecture components, including their interfaces, such as the kernel, shells, and libraries. (b) architecture connectors such as pipes and C header files. (c) architecture patterns [71] that were applied in the system, such as layering and reflection. and (d) the princi- ples that guide the system architecture, such as modularity and separation of concerns. A quantitative point of view. Specifically we look at how metrics of size and complexity evolve over time. these metrics concern system features (e.g. number of user commands or system calls), as determined by the Unix reference documentation ;Yes, after each release using a proprietary method. ;general: # appouch: analysis of unix documentation, analysis of repository of unix history, souce code analysis, measure complexity, calculate cyclomatic complexity, component level, Constant Comparison, Another major force that has been driving the software architecture is portability# tools: ;No;The architecture technical debt is systematically paid back despite increasing system size and complexity. identified, repayment, monitored;;;;;;;Complete
73;Izurieta et al. 2018;8;2018;Clemente Izurieta , Kali Kimball , David Rice , Tessa Valentien;A position study to investigate technical debt associated with security weaknesses;2018;Context: Managing technical debt (TD) associated with potential security breaches found during design can lead to catching vulnerabilities (i.e., exploitable weaknesses) earlier in the software lifecycle. thus, anticipating TD principal and interest that can have decidedly negative impacts on businesses.Goal: To establish an approach to help assess TD associated with security weaknesses by leveraging the Common Weakness Enumeration (CWE) and its scoring mechanism, the Common Weakness Scoring System (CWSS). Method: We present a position study with a five-step approach employing the Quamoco quality model to operationalize the scoring of architectural CWEs. Results: We use static analysis to detect design level CWEs, calculate their CWSS scores, and provide a relative ranking of weaknesses that help practitioners identify the highest risks in an organization with a potential to impact TD.Conclusion:CWSS is a community agreed upon method that should be leveraged to help inform the ranking of security related TD items. ;Conference;"2018 ACM/IEEE International Conference on Technical Debt 
";"International Conference on Technical Debt (TechDebt)
";Technical Debt;"quality assurance, software quality, technical debt 
";5;Our study explores the usage of agreed upon weaknesses (CWEs) as a basis for quantifying TD associated with security issues. Our motivation stems from the fact that a large community effort has already generated a lot of data informed by experts from both industry and academia. Specifically, the Common Weakness Scoring System (CWSS) [17, 22] already provides a mechanism for prioritizing weaknesses according to relevant importance and context. CWSS follows the steps of the Common Vulnerability Scoring System (CVSS), with the former focusing on weaknesses rather than vulnerabilities. This is an important distinction because a weakness is “a shortcoming or imperfection in the software code, design, architecture, or deployment that, could, at some point become a vulnerability”[2] and vulnerabilitie are manifestations of weaknesses at runtime. Thus, since TD is a phenomenon that is best observed during design (i.e. tradeoffs), then CWSS is the appropriate scoring mechanism that should be leveraged. CWSS offers different approaches to calculate a weakness score, of which the Aggregated and Generalized methods offer a one-to-one mapping with our implementation [9] of the Quamoco hierarchical quality model. Further, since TD is more relevant to design issues, as opposed to code level (non- design) issues [18], we only focus on those rules (i.e., CWEs) associated with design at the architectural level [21]. Thus, our goal in this position study is to explore an approach that uses CWSS scores relevant to architectural decisions to help rank TD issues associated with security weaknesses ;No;No;No;No;theorical method;An approach to identify Security TD based on CWSS (Common Weakness Scoring System) A pilot study.;Solution proposal;Architectural compliance issues;Security TD using a catalog of Security Issues provided by CWE (Common Weakness Enumeration);No;" general:""quality assurance, security, Common Weakness Scoring System, Common Vulerability Scoring System, Quamoco, ISO 25010, source code, catalog of flaws, specialist evaluation""
 # 
 approuch:""Pilot study, priorization securty framework, Common Architectural Weakness Enumeration""
 #
 tools:""proprietary score formula, FxCorp""";"PrincipalTD-Security = Cost of the maintenance and refactoring associated with fixing architectural CWEs 
";;There is a lack of study in Security TD. The approuch based in a security catalog widely used in community.;There is no data to proof the approuch. For example: maybe the authors shoud be use a real system to validate the proposal.;problem characterization: yes, bibliographic review: yes, data collection: no, hypothesis: no, experimentation: no, results: yes, final: weak;Good.Due to the applied approuch to identificy the security TD and there is a formula to calculate the Principal of Security TD;The is no validation in a real software system to proof the proposed approuch;No;Complete
69;Besker, Martini and Bosch 2017;25;2017;Terese Besker, Antonio Martini, Jan Bosch;The pricey bill of technical debt: When and by whom will it be paid?;2017;Software companies need to support continuous and fast delivery of customer value both in short and a long-term perspective. However, this can be hindered by evolution limitations and high maintenance efforts due to internal software quality issues by what is described as Technical Debt. Although significant theoretical work has been undertaken to describe the negative effects of Technical Debt, these studies tend to have a weak empirical basis and often lack quantitative data. The aim of this study is to estimate wasted time, caused by the Technical Debt interest during the software life-cycle. This study also investigates how practitioners perceive and estimate the impact of the negative consequences due to Technical Debt during the software development process. This paper reports the results of both an online web-survey provided quantitative data from 258 participants and follow- up interviews with 32 industrial software practitioners. The importance and originality of this study contributes and provides novel insights into the research on Technical Debt by quantifying the perceived interest and the negative effects it has on the software development life-cycle. The findings show that on average, 36 % of all development time is estimated to be wasted due to Technical Debt. Complex Architectural Design and Requirement Technical Debt generates most negative effect. and that most time is wasted on understanding and/or measuring the Technical Debt. Moreover, the analysis of the professional roles and the age of the software system in the survey revealed that different roles are affected differently and that the consequences of Technical Debt are also influenced by the age of the software system. ;Conference;"International Conference on Software Maintenance and Evolution 
";"International Conference on Software Maintenance and Evolution 
";Software Maintenance and Evolution;"Technical Debt, Wasted time, Development Cost, Software Development, Empirical Study, Survey, Qualitative data, Quantitative data 
";11;"There are many different types of TD (such as Architectural TD, Requirement TD, Test TD, Code TD), which differ in the degree of their negative impact and consequently cause various levels of wasted time during the software development process. Several professional roles participate in the software development process, and could possibly be affected by TD in diverse ways. Furthermore, as the software ages, different types of TD could have varying negative effects and could possibly generate a dissimilar distribution of extra time spent on different activities. 
However, little knowledge and few supporting tools are available to measure the extent of TD within a system and, in addition, the time spent on TD related issues is not made explicitly visible and measurable. Without such knowledge, software development organizations do not know the interest that they are paying on the debt, and therefore they might not give TD management the necessary attention. 
We will answer the research questions by using survey data based on software professionals’ perceptions. All survey respondents were experienced in software development, and therefore, their estimates were likely to be formed by what they have heard, observed, and experienced at their workplaces. 
To the best of our knowledge, there are no studies quantifying the interest in terms of how much time (observed, measured or estimated) is wasted due to TD and how this wasted time varies in relation to the system age and its impact on a range of professional software roles. 
To do a survey and interviews to check the following questions: 

RQ1. How much of the overall development time is wasted because of Technical Debt? 
RQ2. What kind of Technical Debt Challenges generates the most negative impact? 
RQ3. What are the various activities on which extra-time is spent as a result of Technical Debt? 
RQ4. In what way does the age of the software system affect the questions stated in RQ1-3? 
RQ5. In what way are the different professional software roles affected by the questions stated in RQ1-3? 
";Yes;Yes;No;Yes;Survey;Survey;Validation Research;Not specified;No;No;No;No;;This is the first study surveying the estimated magnitude of the interest paid on the accumulated TD in terms of perceived wasted time and effort. The study has shown that software development practitioners estimate that 36 % of all development time is wasted due to TD and that Complex Architectural Design and Requirement TD generates the most negative impact on daily software development work.;Not applicable;problem characterization: yes, bibliographic review: yes, data collection: yes, hypothesis: no, experimentation: no, results: yes, final: good;Good. due to demonstrate how important is the effort waste with TD (36%) and the study showed that Software Architecture and Requirements are the aspects most important because waste more time to fix TD.;The qualitative data derived from the survey are not based on measured or observed data but on estimations made by the respondents. ;The qualitative data derived from the survey are not based on measured or observed data but on estimations made by the respondents. In future studies, we plan to include physical measurements and observation, to create a stronger reliability of the data. The result of this research may be affected by some threats to validity.;Complete
67;Ampatzoglou et al 2016;33;2016;Areti Ampatzoglou, Apostolos Ampatzoglou, Alexander Chatzigeorgiou, Paris Avgeriou, Pekka Abrahamsson, Antonio Martini, Uwe Zdun, Kari Systa;The Perception of Technical Debt in the Embedded Systems Domain: An Industrial Case Study  ;2016;Technical Debt Management (TDM) has drawn the attention of software industries during the last years, including embedded systems. However, we currently lack an overview of how practitioners from this application domain perceive technical debt. To this end, we conducted a multiple case study in the embedded systems industry, to investigate: (a) the expected life-time of components that have TD, (b) the most frequently occurring types of TD in them, and (c) the significance of TD against run-time quality attributes. The case study was performed on seven embedded systems industries (telecommunications, printing, smart manufacturing, sensors, etc.) from five countries (Greece, Netherlands, Sweden, Austria, and Finland). The results of the case study suggest that: (a) maintainability is more seriously considered when the expected lifetime of components is larger than ten years. (b) the most frequent types of debt are test, architectural, and code debt. and (c) in embedded systems the run- time qualities are prioritized compared to design-time qualities that are usually associated with TD. The obtained results can be useful for both researchers and practitioners: the former can focus their research on the most industrially-relevant aspects of TD, whereas the latter can be informed about the most common types of TD and how to focus their TDM processes. ;Workshop;"IEEE 8th International Workshop on Managing Technical Debt 
";"International Workshop on Managing Technical Debt (MTD)
";Technical Debt;"technical debt, embedded systems, industry case study 
";8;"To check how practitioners percept Technical Debt in Embedded Systems about Quality Attributes. 
RQ1: What is the relationship between the expected lifetime of components and technical debt? 
RQ2: What types of technical debt (e.g., code, architectural, etc.) are more frequently occurring in embedded systems? 
RQ3: What is the significance of building maintainable software systems (with low TD) compared to satisfying other quality attributes? 

Case study in seven technology companies: 
Telecomunication
 Automotive
 Mobile
 Sensors
 Priting
 Smart Manufacturing
 Media Devices 
";Yes;Yes;No;Yes;Case study;Multiple case study. case study in industry, industrial practice, expert opinion, observation, empirical study in industry, survey;Evaluation research;Not specified;No;No;"general:""lifetime components, embeded systems,  quality attributes, maintainability, reliability, source code, revision history, specialist evaluation, performance, functionality, compatibility, portability, software-intensive domains, long lifetime, Test TD, Code TD, Architecture TD, Documentation TD""
 # 
 approuch:""GQM, questionaries, interview""
 #
 tools:""no""";No;;The study collected real data from a real industry of software embedded using questionaries and interviews about the effort spent on Technical Debt in the embedded system. Thus, the study identified that test TD, code TD, and Architectural TD were highlighted as main kinds of TD, and qualities attributes as functionality, reliability, and performance were the most important in this context.;There are no details about how to identify the TD, and there are no explicit future works.;problem characterization: yes, bibliographic review: yes, data collection: yes, hypothesis: yes, experimentation: no, results: yes, final: good; Good.due to Architectural Technical Debt's findings as an essential kind of TD that happens in the context of embedded systems.;The study did not show how to measure the TD.;No;Complete
66;Martini, Besker and Bosch 2016;14;2016;Antonio Martini, Terese Besker, Jan Bosch;The Introduction of Technical Debt Tracking in Large Companies;2016;Large software companies need to support continuous and fast delivery of customer value both in the short and long term. However, this can be hindered if both evolution and maintenance of existing systems are hampered by Technical Debt. Although a lot of theoretical work on Technical Debt has been recently produced, its practical management lacks empirical studies. In this paper we investigate the state of practice in several companies in order to understand how they start tracking Technical Debt. We combined different methodologies: we conducted a survey, involving 226 respondents from 15 organizations and a more in-depth multiple case-study in three organizations, where Technical Debt was tracked: we involved 13 interviews and 79 Technical Debt issues analysis. We found that the development time dedicated to manage Technical Debt is substantial (around 25% of the overall development) but not systematic: only a few participants methodically track Technical Debt. By studying the approaches in the companies participating in the case-study, we understood how companies start tracking Technical Debt and what are the initial benefits and challenges. Finally, we propose a S trategic Adoption Model based to define and adopt a dedicated process for tracking Technical Debt. ;Conference;Asia Pacific Software Engineering Conference;Asia Pacific Software Engineering Conference;Software engineering;Technical Debt,change management,software process improvement,survey,multiple case-study;8;"The main goal of the paper is to check how is the process of Technical Debt tracking in Large Software Companies. The authors made a survey with practitioners in large software companies, and multiple case study in 3 large software companies in Scandinavia area.  The questions:  

RQ1 How much of the software development time is estimated to be employed in managing TD?
It is also important to understand how a TD tracking process is introduced and implemented in large software companies.We therefore aim at answering the following RQs:
RQ2 To what extent do software organizations track TD?
RQ3 How do software organizations introduce a TD tracking process?
RQ4 What are the initial benefits and challenges when large organizations start tracking TD?
";Yes;Yes;No;Yes;Case study;Survey and Multiple case study. case study in industry, industrial practice, expert opinion, observation, empirical study in industry, survey, proposed theorical method;Evaluation research;Not specified;No;No;No;No;;The authors proposed a maturity model (Strategic Adoption Model (SAMTTD)) to control and manage TD. The following steps cover the model: unaware, no tracking, Ad-hoc, Manual, Measured, Institutionalized and Fully automated. The study observed that the practioners that tracking TD wast about 25% of effort on it.;The is no ATDI issues explicited on the study;problem characterization: yes, bibliographic review: yes, data collection: yes, hypothesis: no, experimentation: no, results: yes, final: good;Good. because there is ATD debt recognized in survey like: Dependence violations, Complex architecture desgin, different parterns and policies, dependence to external resource and lack of reusabililite in design;There is no explanations or details about TD issues used in survey.;In summary, managing TD requires a few investments that are not well known by the practitioners and are difficult to be motivated by a precise cost/benefits ratio. Consequently, without an investment on processes and tools to track TD, it remains difficult to make TD visible. And it is difficult to advocate for refactoring invisible TD. This represents a vicious cycle: companies suffer the negative effects of TD and try to contain it, but at the same time they do not find enough motivations to invest in a more systematic management process. By looking at the motivations for start tracking TD, the results show that organizations do so when they experience the interest of TD: slow feature development, quality issues and performance degradation. However, at such point the interest of the TD is already high and, as explained in our recent papers [6], [10], it is hard to refactor, as the cost has also increased and become too expensive. In conclusion, the only way out the vicious cycle seems to be, for the practitioners, to proactively start tracking TD. However, we do not have evidence yet that such improvement would bring the 25% effort down. This is a long-term study that should be set for future research to conduct;Complete
96;Aaramaa et al 2017;0;2017;Sanja Aaramaa, Sandun Dasanayake, Markku Oivo, Jouni Markkula, Samuli Saukkonen;Requirements volatility in software architecture design: An exploratory case study;2017;Requirements volatility is a major issue in software (SW) development, causing problems such as project delays and cost overruns. Even though there is a considerable amount of research related to requirement volatility, the majority of it is inclined toward project management aspects. The relationship between SW architecture design and requirements volatility has not been researched widely, even though changing requirements may for example lead to higher defect density during testing. An exploratory case study was conducted to study how requirements volatility affects SW architecture design. Fifteen semi-structured, thematic interviews were conducted in the case company, which provides the selection of software products for business customers and consumers. The research revealed the factors, such as requirements uncertainty and dynamic business environment, causing requirements volatility in the case company. The study identified the challenges that requirements volatility posed to SW architecture design, including scheduling and architectural technical debt. In addition, this study discusses means of mitigating the factors that cause requirements volatility and addressing the challenges posed by requirements volatility. SW architects are strongly influenced by requirement volatility. Thus understanding the factors causing requirements volatility as well as means to mitigate the challenges has high industrial relevance.;Conference;ICSSP 2017 Proceedings of the 2017 International Conference on Software and System Process;International Conference on Software and System Process;Software and System Process;Requirement management, software architecture;10;"To provide empirical insights into requirements volatility from SW architects’ point of view, an industrial case study was conducted to explore requirements volatility in the context of SW architecture design. Fifteen SW architects involved in architecture design were interviewed for the case, the objective of which was to identify challenges that SW architects face due to requirements volatility and to propose means to address those challenges. The following research questions were derived from the objectives of the case. 
RQ1: What are the factors that cause requirement volatility? 
RQ2: What challenges does requirements volatility pose to SW architecture design? 
RQ3: What are means to address the identified challenges in SW development? ";Yes;Yes;No;Yes;Case study;Exploratory case study;Validation Research;Violations of good architectural practices;No;No;No;No;;The paper showed a case study about the impact of requirements in software architecture.;Weak, due to the author did not study about how to identify, measure or calculate ATD;problem characterization: yes, bibliographic review: yes, data collection: yes, hypothesis: no, experimentation: no, results: no, final: weak;Weak. due to the author did not study about how to identify, measure or calculate ATD;This study aimed to explore the challenges to SW architecture posed by requirements volatility, but it not concern to identify, measure or calculate the cost of ATD.;In future research, another case study will be conducted in a company of different size and in a different domain to investigate whether the same challenges are present there. Cross analysis between the case studies will provide new insights and help increasing the generalisability of the findings. Based on the results of those case studies, it is planned to develop a framework that provides means for practitioners to identify the presence of challenges posed by requirement volatility and take necessary steps to mitigate the risks. ;Complete
35;Martini et al 2015;65;2015;Antonio Martini, Jan Bosch, Michel Chaudron;Investigating Architectural Technical Debt accumulation and refactoring over time: A multiple-case study ;2015;"Context: A known problem in large software companies is to balance the prioritization of short-term with long-term feature delivery speed. Specifically, Architecture Technical Debt is regarded as sub-optimal architectural solutions taken to deliver fast that might hinder future feature development, which, in turn, would hinder agility. 
Objective: This paper aims at improving software management by shedding light on the current factors responsible for the accumulation of Architectural Technical Debt and to understand how it evolves over time.
Method: We conducted an exploratory multiple-case embedded case study in 7 sites at 5 large companies. We evaluated the results with additional cross-company interviews and an in-depth, company-specific case study in which we initially evaluate factors and models. 
Results: We compiled a taxonomy of the factors and their influence in the accumulation of Architectural Technical Debt, and we provide two qualitative models of how the debt is accumulated and refactored over time in the studied companies. We also list a set of exploratory propositions on possible refactoring strategies that can be useful as insights for practitioners and as hypotheses for further research. Conclusion: Several factors cause constant and unavoidable accumulation of Architecture Technical Debt, which leads to development crises. Refactorings are often overlooked in prioritization and they are often triggered by development crises, in a reactive fashion. Some of the factors are manageable, while others are external to the companies. ATD needs to be made visible, in order to postpone the crises according to the strategic goals of the companies. There is a need for practices and automated tools to proactively manage ATD";Journal;"Information and Software Technology  Journal";"Information and Software Technology  Journal";Software and System Process;"Architectural Technical Debt, Software management, Software architecture,  Agile software development, Software life-cycle, Qualitative model ";17;"This paper aims at improving software management by shedding light on the current factors responsible for the accumulation of Architectural Technical Debt and to understand how it evolves over time.

In this paper we aim at filling such current gaps by investigating, in several companies, the overall phenomenon of accumulation and refactoring of ATD. The study of such subject would also contribute to ASD frameworks, by highlighting activities for enhancing agility in the task of developing and maintaining software architecture in large projects [5]. 
In the context of large-scale ASD, our research questions are: 
RQ1: What factors cause the accumulation of ATD?
RQ2: How is ATD accumulated and refactored over time? RQ3: What possible refactoring strategies can be employed for managing ATD? 

";Yes;Yes;No;Yes;Case study;"A multiple-case study. Interviews in 5 different companies.. case study in industry, industrial practice, expert opinion, observation, empirical study in industry, survey";Evaluation research;Not specified;Yes;Yes;general: # approuch: 'Taxonomy of ATD'# tools: ;Yes, using quality model to check increasing or decreasing of ATD accumulation;Yes. identify, measure, monitoring;;;problem characterization: yes, bibliographic review: yes, data collection: yes, hypothesis: no, experimentation: yes, results: yes, final: good;Good;;;Complete
24;Cai el al 2018;15;2018;"Yuanfang Cai, Lu Xiao, Rick Kazman, Ran Mo, Qiong Feng 
";Design Rule Spaces: A New Model for Representing and Analyzing Software Architecture;2018;In this paper, we propose an architecture model called Design Rule Space (DRSpace). We model the architecture of a software system as multiple overlapping DRSpaces, reflecting the fact that any complex software system must contain multiple aspects, features, patterns, etc. We show that this model provides new ways to analyze software quality. In particular, we introduce an Architecture Root detection algorithm that captures DRSpaces containing large numbers of a project’s bug-prone files, which are called Architecture Roots (ArchRoots). After investigating ArchRoots calculated from 15 open source projects, the following observation become clear: from 35% to 91% of a project’s most bug-prone files can be captured by just 5 ArchRoots, meaning that bug-prone files are likely to be architecturally connected. Furthermore, these ArchRoots tend to live in the system for significant periods of time, serving as the major source of bug-proneness and high maintainability costs. Moreover, each ArchRoot reveals multiple architectural flaws that propagate bugs among files and this will incur high maintenance costs over time. The implication of our study is that the quality, in terms of bug-proneness, of a large, complex software project cannot be fundamentally improved without first fixing its architectural flaws. ;Conference;International Conference on Software Engineering in 2014 ;International Conference on Software Engineering;Software Engineering;"Software architecture, reverse-engineering, defect prediction, technical debt, code smells, bug localization 
";27;"In this paper, we report on our investigation of using DRSpaces to reveal the architectural impact of bug-prone files. 
In this paper, we show, using DRSpaces, that we can automatically identify architectural flaws that contribute to bug-proneness in a software project. This is achieved by automatically identifying a minimal set of DRSpaces that connect the top bug-prone files in the system. We call these DRSpaces Architecture Roots (ArchRoots). We hypothesize that the ArchRoots have deep-seated and enduring impacts on the bug-proneness of a project. They propagate bugs among files, making bugs hard to eradicate, and consequently causing maintenance costs to increase over time. As we will show, developers can not systematically reduce the bug rate of a project without fixing these ArchRoots first 
";Yes;No;Yes;Yes;case study;;Validation Research;Architecture Smells;Architectural Root;Yes, after each release using a proprietary method. ;general: # approuch: 'DRSpace, Architectural Root, Architecture Smell, DSM, DRH, Coupling, source code analysis'# tools: latix;Yes, using a proprietary formula to calculate the effort to fix the architecture root;Yes;;;problem characterization: yes, bibliographic review: yes, data collection: yes, hypothesis: no, experimentation: yes, results: yes, final: good;good.;;;Complete
77;Bogner et al 2019;10;2019;Justus Bogner, Jonas Fritzsch, Stefan Wagner, Alfred Zimmermann;Assuring the Evolvability of Microservices: Insights into Industry Practices and Challenges  ;2019;"While Microservices promise several beneficial characteristics for sustainable long-term software evolution, little empirical research covers what concrete activities industry applies for the evolvability assurance of Microservices and how technical debt is handled in such systems. Since insights into the current state of practice are very important for researchers, we performed a qualitative interview study to explore applied evolvability assurance processes, the usage of tools, metrics, and patterns, as well as participants’ reflections on the topic. In 17 semi-structured interviews, we discussed 14 different Microservice-based systems with software professionals from 10 companies and how the sustainable evolution of these systems was ensured. Interview transcripts were analyzed with a detailed coding system and the constant comparison method. 
We found that especially systems for external customers relied on central governance for the assurance. Participants saw guidelines like architectural principles as important to ensure a base consistency for evolvability. Interviewees also valued manual activities like code review, even though automation and tool support was described as very important. Source code quality was the primary target for the usage of tools and metrics. Despite most reported issues being related to Architectural Technical Debt (ATD), our participants did not apply any architectural or service-oriented tools and metrics. While participants generally saw their Microservices as evolvable, service cutting and finding an appropriate service granularity with low coupling and high cohesion were reported as challenging. Future Microservices research in the areas of evolution and technical debt should take these findings and industry sentiments into account. 
Index Terms—Microservices, interviews, industry, evolvability, assurance ";Conference;IEEE International Conference on Software Maintenance and Evolution (ICSME) ;International Conference on Software Maintenance and Evolution (ICSME) ;Software Maintenance and Evolution;"Microservices, interviews, industry, evolvability, assurance 
";11;"We formulated three research questions to set a direction and scope for our study: 
RQ1: How do software professionals structure the general evolvability assurance activities for Microservices and for what reasons? 
RQ2: What tools, metrics, and patterns do software professionals use for assuring the evolvability of Microservices and with what rationales?
 RQ3: How do software professionals perceive the quality of their Microservices and assurance processes and what parts are seen as challenging? 
";Yes;Yes;No;Yes;Survey;Survey about micro-service;Validation Research ;Complex architectural behavioral dependencies;No;No;No;No;;The authors conducted a study to check the perception of maintanance and evolution of microservices via survey in 10 IT companies from Germany.;The study did not show details about identification, measure or calculate the cost of ATDI.;problem characterization: yes, bibliographic review: yes, data collection: yes, hypothesis: no, experimentation: no, results: yes, final: regular;Good. due to the authors conducted a survey to check the perception of architectural technical debt in micro-services, Despite most reported issues being related to Architectural Technical Debt (ATD), our participants did not apply any architectural or service-oriented tools and metrics. So, it is a good oportunite to study ATD in microservices.;The amount of participantes were 17 stakeholders from 10 diferent companies from Germany. Maybe a small number to represent the perception for all companies.;"No architectural tools and metrics were applied, even though most reported challenges and issues like service cutting were related to software architecture. This may indicate the im- portance of Architectural Technical Debt (ATD) management for Microservices. 

Future work that covers the areas of maintenance, evolution, and technical debt in the context of Microservices should take these findings and industry sentiments into account. In particular, academia can support industry with methods, metrics, or tools that aid macroarchitectural assessment of Microservices or provide a more system-centric view. We perceived tool support for service cutting activities and metrics to evaluate service granularity, coupling, or cohesion as concrete gaps that could save industry a lot of refactoring efforts. Finally, issues in the area of human evolvability factors with Microservices like the handling of hyped technologies as well as coordinating and exchanging knowledge between decentralized teams were
described as important by participants.";Complete
78;Ludwig and Webber 2017;12;2017;Jeremy Ludwig,  Steven Xu, Frederick Webber;"Compiling Static Software Metrics for Reliability and Maintainability from GitHub Repositories 
";2017;This paper identifies a small, essential set of static software code metrics linked to the software product quality characteristics of reliability and maintainability and to the most commonly identified sources of technical debt. A plug-in is created for the Understand code visualization and static analysis tool that calculates and aggregates the metrics. The plug-in produces a high-level interactive html report as well as developer-level information needed to address quality issues using Understand. A script makes use of Git, Understand, and the plug-in to compile results for a list of GitHub repositories into a single file. The primary contribution of this work is to describe an open-source plug-in to measure and visualize architectural complexity based on the propagation cost and core size metrics, which are not currently found in other tools. The plug-in should be useful to researchers and practitioners interested in these two metrics and as an expedient starting point to experimentation with metric collection and aggregation for groups of GitHub repositories. The plug-in was developed as a first step in an ongoing project aimed at applying case-based reasoning to the issue of software product quality. ;Conference;"IEEE International Conference on Systems, Man, and Cybernetics (SMC) 
";"International Conference on Systems, Man, and Cybernetics (SMC) 
";Software Engineering;"software product quality,technical debt,reliability, maintainability, architecture, metrics, static code analysis 
";5;"There are several practical software quality models and tools that have been recently developed and that generally include an automated measurement of technical debt . However, by default, the measured technical debt may not be an accurate measure of product quality issues . While some technical debt is unavoidable, a large survey of software engineers and architects across multiple organizations provides a practical view of the causes and sources of avoidable technical debt. Their results indicate that architectural decisions, overly complex code, and lack of code documentation are the top three avoidable sources of technical debt in practice. 
";No;No;No;No;propose a tool;propose a tool;Solution proposal;System-level structure quality issues;No;No;"general:""architectural complexity, propagation cost, complexity metrics, Design Structure Matrix, Treemap, source code, coupling, coupling between objects,  reliability, maintainability, static code analysis, architectural metrics, core size, DSM""
 # 
 approuch:""plugin to collect information""
 #
 tools:""proprietary plugin, Understand""";No;;The authors collected important metrics regard to architectural metrics and complex metrics.The authors created a usefull plugin that take a way good information to manager and devolopers about architectural metrics and complex metrics directy from github repositories. The plugin is available on https://www.scitools.com/support/gui-plugins/ as called Understand;The dataset used in study was not available to reproduce the results;problem characterization: yes, bibliographic review: yes, data collection: yes, hypothesis: no, experimentation: no, results: yes, final: regular;Good. due to the metrics grouped by the authros;There is no ATD index or specific metrics to architectural technical debt;"While the plug-in is useful as-is, it was developed as a first step in an ongoing project aimed at applying case-based reasoning to the issue of software product quality. The next step in this project aims to use the described plug-in as part of a research effort to define and validate the aggregation of these metrics as part of a software quality model.
";Complete
81;Curtis et al 2012;109;2012;Bill Curtis, Jay Sappidi, Alexandra Szynkarski, ;Estimating the principal of an applications technical debt;2012;For the technical debt metaphor to be useful, its constructs must be measurable or at least estimable from measurable elements of software. Fortunately, we can estimate the violations underlying TD-principal via tech- niques such as static analysis of the software’s nonfunctional, structural characteristics.3 Violations of struc- tural quality are often difficult to de- tect through standard testing but are frequent causes of severe operational problems.;Journal;IEEE Software;IEEE Software;Technical Debt;IEEE Newspaper;9;"Analyse a set of application from Cast database system tWe analyzed these applications us- ing CAST’s Application Intelligence Platform (AIP),7 which analyzes an en- tire application using more than 1,200 rules to detect violations of good ar- chitectural and coding practice. We drew these rules from software engi- neering literature, repositories such as the Common Weakness Enumeration (CWE. cwe.mitre.org), online discus- sion groups of structural quality prob- lems, and customer experience as re- ported from defect logs and application architects. As an example, security- related violations would include SQL injection, cross-site scripting, buffer overflows, and other violations from the CWE. 
";Yes;Yes;No;Yes;Case study;Case study, case study in industry, industrial practice, expert opinion, observation, empirical study in industry;Evaluation research;Violations of good architectural practices;yes, it was meausre a number of detected violations based on qualite attributes (Performance, Robustness, Security Transferabililty, Changeability);No;"general:""language parse, meta-model, catalogs of rules, application analysis, detected violations, quality attributes, performance, robustness, security, changeability, transferability, source code, revion history, business risk, ""
 # 
 approuch:""Detected Violation, proprietary formula""
 #
 tools:""CAST, proprietary formula""";"TD-Principal =
(Σ high severity violations) x .5) 1 hr.) x 75$) +
(Σ medium severity violations) x .25) 1 hr.) x 75$) + (Σ low severity violations) x .1) 1 hr.) x 75$)";;The authors performed a study in a real case using a real it company catalog of rules of architectural and code patterns with real systems. The authors proposed a was to calculate the principal of TD in money value.;The catalog of rules is private. So, only the CAST company can use this catalog. Besides, the value used to calculate the principal of TD is regarding to context of CAST company, thus, it not possible to generalize this value in other companies.;problem characterization: yes, bibliographic review: yes, data collection: yes, hypothesis: no, experimentation: no, results: yes, final: regular;Good. due to the authors proposed an effetive way to calculate the principal of TD based on catalog of rules to detect the violations of qualities attributes like performance, securtiy, robustness, trasferability and changeabilite. So, those characteristics are so close to architectural technical debt.;The catalog of rules is private. So, only the CAST company can use this catalog. Besides, the value used to calculate the principal of TD is regarding to context of CAST company, thus, it not possible to generalize this value in other companies.;The next step in our exploration of TD-principal is to provide individual ratings for the effort to fix each of the 1,200+ violations. These effort ratings will be further adjusted by the number of components involved in fixing the violation and the complexity of each component. This refinement will make the calculation of TD-principal more granular and could provide better in- dicators of components most in need of refactoring;Complete
85;Kumar et al 2018;1;2018;M. Manoj Kumar, A. Nandakumar;Exploring multilateral cloud computing security architectural design debt in terms of technical debt  ;2018;"This work identifies various design debt causes in a cloud computing system from various dimensions of design debt. Even though immature, un-ripen coded service accessible over the Internet using the cloud computing paradigm may work fine and be wholly tolerable to the patron. but excess quantities will make a service progression that may lead to extreme specialist of software developers and finally an inflexible product. Delivery of the earliest primary beginning coded service without ripeness or maturity is like going into debts or arrears or due to obligation. A petite tiny debt rates progress so protracted as it is paid or rewarded back punctually with a rewrite/redraft/revising/reworking. The risk arises when the debt is not repaid and settled. Every miniature infinitesimal effort spent on imprecise code reckons as interest on that arrears/debt. Intact engineering business can be brought to be idle under the balance load of an unconsolidated, non-solicit implementation, execution, and performance discharging object-oriented, func- tional or procedural or otherwise. This work uses refactoring as a solution for the identified debt in the multilateral cloud security architecture to secure the cloud services. 
";Book series;"Springer Nature Singapore Pte Ltd. 2018 
";"Springer Nature Singapore
";Cloud Computing;Multilateral cloud security, architecture Design smells,Technical debt, Design debt, Cloud computing security, Design refactoring ;13;"Two insights that we come out of our work practice with designing/architecting/coding in real production world cloud computing services or applications/resources are: security risk, threat/problem. 
Context milieu circumstance, perspective framework stages participates with a big role in cloud service or resource security design and architecture.
Security risk, threat, attack, issues, problem patterns are anticipated excellent elucidation, but purely on whence we relate the situation and apply them in fitting right security design context and the problem/risk with measure. 
";No;No;No;No;Case study;Case study;Solution proposal;Architectural compliance issues;Security TD;No;No;No;No;;;problem characterization: yes, bibliographic review: yes, data collection: no, hypothesis: no, experimentation: no, results: yes, final: weak;Weak;;;Complete
88;Hanssen et al 2019;2;2019;Geir Kjetil Hanssen, Gunnar Brataas, Antonio Martini;Identifying Scalability Debt in Open Systems;2019;"Architectural technical debt can be generated by changes in the business and the environment of an organization. In this paper, we emphasize the change in scalability requirements due to new regulations. Scalability is the ability of a system to handle an increased workload. For complex systems that are abruptly exposed via open interfaces and hence a greater workload, the scalability requirements may quickly increase, leading to technical debt. We term this scalability debt. This paper describes scalability triage, a light-weight, novel technique for identifying scalability threats as a form of technical debt. We illustrate this technique with an open banking case from a large software organization. Open banking is partly caused by the new European PSD2 regulative that enforce banks to open interfaces to unknown third-party actors. Banking systems are well-established, mature systems. However, with the advent of open banking and PSD2, the workload may quickly rocket. This leads to tougher scalability requirements and accumulated architectural debt, despite previously sound architectural decisions. Using scalability triage, such risks may be identified fast. It will then be possible to prevent this form of technical debt with timely reengineering.
";Conference;2019 IEEE/ACM International Conference on Technical Debt (TechDebt);International Conference on Technical Debt (TechDebt);Technical Debt;agile development, scalability requirements, scalability triage, open banking;5;"Our goals in this paper are: (1) To advocate for the necessity to study novel and lightweight approaches to manage scalability debt in open systems. And, (2) To provide a first preliminary study of a lightweight analysis method that can support managing scalability debt in open systems.

The subsequent RQ is: How can we identify, estimate and prioritize scalability debt in open systems?";Yes;Yes;No;Yes;Case study;case study in industry, industrial practice, expert opinion, observation, empirical study in industry, proposed theorical method;Evaluation research;System-level structure quality issues;Scalability through estamating impact in the subsystems;No;" general:""scalability, quality metrics, scalability triage, affected subsystems, estimating impact, specialist evaluation, performance, software architecture documentation, open systems""
 # 
 approuch:""lightweight approuch to identify scalability debt""
 #
 tools:""no""
";No;;Describe a kind of ATD, more spefically scalability ATD and the authors proposed a lightweight approach to manage scalibity debt. The case study conducted a method to identify, estimate and prioritize scalability debt.;The approuch to identify, estimate and calculate the scabality architectural issue is manual.;problem characterization: yes, bibliographic review: yes, data collection: yes, hypothesis: yes, experimentation: yes, results: yes, final: good;Good.due to the authors proposed a method to identify, estimate and prioritize a kind of ATD, more specifically scalability debt.;The approuch to identify, estimate and calculate the scabality architectural issue is manual.;It is necessary to study other aspects of ATD such as measurement, monitoring, priorization, repayment and communication and documentation. The results can be taken into consideration by practitioners when dealing with scalability debt and may be used as starting point to develop the method presented here furher or t resear novel lightweight approaches to manage technical debt related to other key business qualities;Complete
90;Sierra et al 2019;6;2019;G Sierra, A Tahmid, E Shihab, N Tsantalis.	;Is Self-Admitted Technical Debt a Good Indicator of Architectural Divergences?  	;2019;Large software systems tend to be highly complex and often contain unaddressed issues that evolve from bad design practices or architectural implementations that drift from definition. These design flaws can originate from quick fixes, hacks or shortcuts to a solution, hence they can be seen as Technical Debt. Recently, new work has focused on studying source code comments that indicate Technical Debt, i.e., Self-Admitted Technical Debt (SATD). However, it is not known if addressing information left by developers in the form source code comments can give insight about the design flaws in a system and have the potential to provide fixes for bad architectural implementations. This paper investigates the possibility of using SATD comments to resolve architectural divergences. We leverage a data set of previously classified SATD comments to trace them to the architectural divergences of a large open source system, namely ArgoUML. We extract its conceptual and concrete architectures based on available design documentation and source code, and contrast both to expose divergences, trace them to SATD comments, and investigate their resolution. We found 7 high-level divergences in ArgoUML and 22 others among its subsystems, observing that merely 4 out of 29 (14%) divergences can be directly traced to SATD. Although using SATD as an indicator of architectural divergences is viable, the effort of doing so is time-intensive, and in general, will not lend to a significant reduction of architectural flaws in a software system.;Conference;SANER 2019;International Conference on Software Analysis, Evolution and Reengineering;Software Engineering;"Self-Admitted Technical Debt, Software Re-Engineering, Software Architecture, Architecture Recovery 
";10;"As preliminary work for our investigation, we identify the architectural divergences that have occurred over time in ArgoUML. We achieve this by obtaining and contrasting the concrete and conceptual architectures of the system based on available documentation and the source code of the project. We replicate techniques from previous work. where alongside the goals and findings of each study, their authors were able to expose many unexpected and missing dependencies between subsystems in an architecture (archi- tectural divergences). Bowman and Brewster pointed out that many of the unexpected dependencies they found in Linux could not be explained by rationale and their occurrence is due to developers bad practices or expediency. Since identifying SATD exposes problems acknowledged by developers, we investigate if SATD can be a good indicator of said unwanted links between subsystems. 
We examine the following research questions for our study: 
	RQ1 - How many architectural divergences can be traced to SATD comments? 
	RQ2 - How many architectural divergences can be fixed by addressing SATD? 

";Yes;No;Yes;Yes;Case study;Case study on Open Source Project;Validation Research;Not specified;No;No;" general:""Self-admitted Technical Debt, architecture recovery, component dependencies, software architecture documentation, source code, architecture violation, reverse engineering, architectural divergences, depencencies per component""
 # 
 approuch:""framework to recover the architecture""
 #
 tools:""proprietary tool""
";No;;The authors recovery the software architecture compoents from ArgoUML analysing the documents and source code. So, it is can be shared with others papers;The dataset was not available to reproduce the study;problem characterization: yes, bibliographic review: yes, data collection: yes, hypothesis: no, experimentation: yes, results: yes, final: regular;Good.due te the paper show a approuch to identify architectural divergences using Self Admited Technical Debt using comments from source code.;The authors conducted only one study to only one product: ArgoUML, so, it not possible to generalize the results to other products;To generalize our findings, we plan on replicating this study on a broader scale. Looking at SATD comments that can be traced to architectural divergences resulted effective in resolving them, thus, we plan to further investigate this with better architectural recovery and more advanced SATD detection approaches, potentially in an automated manner.;Complete
91;Bogner et al 2018;10;2018;Justus Bogner,Jonas  Fritzsch,Stefan Wagner,Alfred  Zimmermann;Limiting technical debt with maintainability assurance: an industry survey on used techniques and differences with service and microservice-based systems;2018;"Maintainability assurance techniques are used to control this quality attribute and limit the accumulation of potentially unknown technical debt. Since the industry state of practice and especially the handling of Service- and Microservice-Based Systems in this regard are not well covered in scientific literature, we created a survey to gather evidence for a) used processes, tools, and metrics in the industry, b) maintainability-related treatment of systems based on service-orientation, and c) influences on developer satisfaction w.r.t. maintainability. 60 software professionals responded to our online questionnaire. The results indicate that using explicit and systematic techniques has benefits for maintainability. The more sophisticated the applied methods the more satisfied participants were with the maintainability of their software while no link to a hindrance in productivity could be established. Other important findings were the absence of architecture-level evolvability control mechanisms as well as a significant neglect of service-oriented par- ticularities for quality assurance. The results suggest that industry has to improve its quality control in these regards to avoid problems with long-living service-based software systems. 
";Conference;"2018 ACM/IEEE International Conference on Technical Debt 
";"International Conference on Technical Debt (TechDebt)
";Technical Debt;"Maintainability, software quality control, survey, industry, service-based systems, micro service-based systems 
";9;"Service-Based Systems (SBSs) promised to bring a number of structural benefits to software maintainability, which has been sup- ported by several studies (e.g. [16, 18]). In recent years, an agile, light-weight, and DevOps-focused service-oriented variant called Microservice-Based Systems (μSBSs) gained popularity and is now trying to renew this promise for a second time. While service orien- tation can bring several benefits, the different levels of abstraction make it also important to revise and adapt design, development, and quality control mechanisms, as for example reported by Voelz and Goeb [23]. Especially in the context of microservices, technological heterogeneity and decentralization of control can have negative impacts on the maintainability of a composed application, if not treated appropriately. 

We therefore created a survey for software professionals to gain insights into their notion of maintainability assurance, more specif- ically a) their used processes, tools, and metrics, b) potentially different treatment of SBSs and μSBSs w.r.t. maintainability control, and c) influences on their satisfaction w.r.t. their maintainability- related actions. Note that while we are aware of existing differences between Service-Oriented Architecture (SOA) and Microservices [5], we focused on their similarities in this paper and explicitly chose the term “Service-Based Systems”, which is not as connected to enterprise-wide governance, standardization, and centralization as SOA.

This leads to the following research questions for our survey:
RQ1: What processes, tools, and metrics are used in the industry to measure and control maintainability?
RQ2: Is the usage of maintainability control different for Service- or Microservice-Based Systems?
RQ3: What correlations exist between applied maintainability controls and participants’ overall view of maintainability in their project?
";Yes;No;Yes;Yes;survey;Survey;Validation Research;System-level structure quality issues;"The perception of: 
Maintainability 
Test coverage
Cyclomatic complexity
Clone coverage
Coupling metrics
Architectural Violation";No;" general:""maintainability, microservices,Test coverage, Cyclomatic complexity, Clone coverage, Coupling metrics, Architectural Violation, Outated documentation, Inadequate testing, architectural erosion, problematic dependencies, complex components, large components, duplicate code, outdated libraries, quality atributes""
 # 
 approuch:""survey""
 #
 tools:""Sonarqube, Findbugs, Self-made tool, Checkstyle, PMD, Jmetrics, Lattix, CAST, CodeCov, Error Prone""
";No;;The authors showed in the study that there is lack research in quality characteristics and Technical Debt in service and micro-service based systems. Besides, the paper shows the perception of practioners about those topics. ;The dataaset of survey should be shared in a .repository or replication kit;problem characterization: yes, bibliographic review: yes, data collection: yes, hypothesis: no, experimentation: no, results: yes, final: regular;Regular. due to the authors highlited that maintanability and evoluation are TD topics with lack studies in services and micro-services based systems.;The survey desig did not show details about the kind of systems and there is no details about the companies that the participants work.;"The is no a explicit future works, but the authors show that of the participants that reported different treatment, no one mentioned how potential maintainability-related problems with increased technological heterogeneity, decentralization of control, or appropriate service granularity could be addressed. While these topics do not necessarily have to negatively impact maintainability, they still hold the potential to do so, if not executed with some care. Since this is a rather young topic, qualitative interviews with experts in the field of Microservices would most likely be a more effective approach.
";Complete
97;Andrzej Zalewski 2017;0;2017;Andrzej Zalewski;Risk Appetite in Architectural Decision-Making;2017;This paper is an exploratory study on architects' attitudes towards risk and its influences on the architectural decision-making process. A classification of architects' attitude to risk-taking has been developed on the basis of Fowler's Technical Debt Quadrants. The core proposition of the paper is that the well-established concept of `risk appetite' can be equally well applied to characterise and classify architects' attitudes towards risk. This enables the aspects of the decision-making process that are influenced by architects' attitudes towards risks to be identified, and reveals what these influences are. It has been shown that the proposed classifications reflect many real-world situations.;Conference;IEEE International Conference on Software Architecture Workshops (ICSAW);International Conference on Software Architecture Workshops (ICSAW);Software Architecture;risk, risk appetite, architecture decision-making;4;"Architectural decisions shape the properties of software systems and may put quality [7] and buildability [8] at risk. Architects may represent a varied attitude towards such architectural risks. For example, some may take risks eagerly, in an attempt to exploit opportunities to improve some of the software quality attributes, while others may be reluctant to take any risk. The general research question is how architects’ attitude towards risk influences the decision-making process. This translates into following research questions: 
RQ.1. How are architectural risks taken? 

RQ.2. Which aspects of the architectural decision- making process are influenced by architects’ attitude towards risk? 

RQ.3. How should architects’ attitudes towards architectural risks be classified? 

RQ.4. Does the proposed classification reflect real world cases? 
";No;No;No;No;theorical method;Theorical;Philosophycal paper;Not specified;No;No;No;No;;The author proporse a therorical important architect risk appetite classification.;But the author did not work about architectural technical debt, only about behavior of software architect about risk.;problem characterization: yes, bibliographic review: yes, data collection: no, hypothesis:no, experimentation: no, results: no, final: weak;Weak. due to the author did not study about ATD;There is no data or experimentation about the study. So, this is a theorical study.;The author want to do a survey in real world about risk architecture in software industry.;Complete
40;Damian A. Tamburri 2019;3;2019;Damian A. Tamburri;Software Architecture Social Debt: Managing the Incommunicability Factor;2019;"Architectural technical debt is the additional project cost connected to technical issues nested in software architectures. Similarly, many practitioners have already experienced that there exists within software architectures a form of social debt, that is, the additional project cost connected to sociotechnical and orga- nizational issues evident in or related to software architectures. This paper illustrates four recurrent antipatterns or community smells connected to such architectural social debt and outlines a means to measure the additional project cost connected to their underlying cause: decision incommunicability. Evaluating the results in multiple focus groups, this paper concludes that studying social debt and community smells at the architecture level may prove vital to rid software development communities of critical organizational flaws incurring considerable additional cost.
Index Terms—Social debt, social debt cost estimation, social debt in software architecting, technical debt.";Journal;IEEE TRANSACTIONS ON COMPUTATIONAL SOCIAL SYSTEMS;TRANSACTIONS ON COMPUTATIONAL SOCIAL SYSTEMS;Computation Social Systems;Social debt, social debt cost estimation, social debt in software architecting, technical debt.;18;"To flesh out the above-mentioned objective, three main RQs were formulated. 
RQ1: Are there any community smells emerging in the process of software architecting? 
RQ2: Provided that architectural community smells do exist, can the extent of the impact for reported community smells be measured? 
RQ3: Can social debt be addressed and mitigated? 


The results, in this paper, stem from a longitudinal, real-life industrial case study and were confirmed using industrial focus groups. 
More specifically, to confirm the validity of the architec- tural social debt community smells and their measurement framework reported in this paper, the connected notions were stressed in two industry–academy mixed focus groups as part of a Dagstuhl Seminar on Technical Debt.1 The focus groups counted a total of nine senior members from several top industrial players, including Google, CAST Software, HP Inc., and VNomic. As part of the results of the focus groups, the validity of the architectural social debt community smells reported in this paper along with the DAHLIA framework to manage them was confirmed. Furthermore, the involved prac- titioners allowed a deeper exploration of previously unknown dimensions over the social debt phenomenon. For example, the definition and ramifications of social debt as a metaphor were refined with an even deeper relation to technical debt—a form of sociotechnical debt, wherefore the social causes always lead to nasty technical phenomena as well (e.g., code churn, unwanted changes, replicated code, and more). This latter form of sociotechnical debt reflects additional project cost which is caused by suboptimal sociotechnical decisions but manifests as negative and invisible characteristics in source code or connected software artifacts (e.g., requirements, software architecture, documentation, and so on) rather than delays or communication friction across the organizational structure. 
";Yes;Yes;No;Yes;case study;Case study;Evaluation research;Not specified;Archtecture Social Debt, architecture incommunicability;No;No;Yes, using a proprietary formula to calculate the effort to fix the social smell.;No;;Not Applicable because it is a framework that creates a graph with socialtechnical network extracted from each architecture decision;;;;;Complete
106;Verdechia, Kruchten and Lago 2020;;2020;Roberto Verdecchia, Philippe Kruchten, Patricia Lago;Architectural Technical Debt: A Grounded Theory;2020; Architectural technical debt in a software-intensive system is driven by design decisions about its structure, frameworks, technologies, languages, etc. Unlike code-level technical debt, which can be readily detected by static analysers, and can often be refactored with minimal efforts, architectural debt is hard to detect, and its remediation is wide- ranging, daunting, and often avoided. The objective of this study is to develop a better understanding of how software development organisations conceptualize their architectural debt, and how they deal with it, if at all. We used a grounded theory method, eliciting qualitative data from software architects and senior technical staff from a wide range of software development organizations. The result of the study, i.e., the theory emerging from the collected data, constitutes an encompassing conceptual theory of architectural debt, identifying and relating concepts such as symptoms, causes, consequences, and management strategies. By grounding the findings in empirical data, the theory provides researchers and practitioners with evidence of which crucial factors of architectural technical debt are experienced in industrial contexts.;Conference;Software Architecture: 14th European Conference, ECSA 2020;European Conference on Software Architecture;Software Architecture;Software Architecture, Technical Debt, Grounded Theory;17;;Yes;Yes;No;Yes;theorical method;Theorical;Philosophycal paper;Not specified;No;Yes;No;No;;-;-;-;-;-;-;Complete
107;Pujols, Josep Burgaya, et al. 2020;;2020;Josep Burgaya Pujols ,Pieter Bas Pieter Bas, Silverio Martínez-Fernández,Antonio Martini,Adam Trendowicz;Skuld: a self-learning tool for impact-driven technical debt management;2020;As the development progresses, software projects tend to accumulate Technical Debt and become harder to maintain. Multiple tools exist with the mission to help practitioners to better manage Technical Debt. Despite this progress, there is a lack of tools providing actionable and self-learned suggestions to practitioners aimed at mitigating the impact of Technical Debt in real projects. We aim to create a data-driven, lightweight, and self-learning tool positioning highly impactful refactoring proposals on a Jira backlog. Bearing this goal in mind, the first two authors have founded a startup, called Skuld.ai, with the vision of becoming the go-to software renovation company. In this tool paper, we present the software architecture and demonstrate the main functionalities of our tool. It has been showcased to practitioners, receiving positive feedback. Currently, its release to the market is underway thanks to an industry-research institute collaboration with Fraunhofer IESE to incorporate self-learning technical debt capabilities.;Conference;International Conference on Technical Debt (TechDebt);International Conference on Technical Debt (TechDebt);Technical Debt;Technical Debt, Project Management, Tool, Data-Driven Development;2;Create a tool to monitor Technical Debt information over the repository and issue tracker using a self-learing method to predict Technical Debt.;No;No;No;No;;propose a tool;Validation Research;Architecture Smells;Yes;Yes;"general:""issue track, machine learning""
# 
approuch:""""
#
tools:""Skuld""
";Yes;Yes;-;-;-;-;-;No;Complete
108;Molnar, Arthur-Jozsef, and Simona Motogna 2020;;2020;Arthur-Jozsef Molnar,Simona  Motogna;Long-Term Evaluation of Technical Debt in Open-Source Software;2020;Background: A consistent body of research and practice have identified that technical debt provides valuable and actionable insight into the design and implementation deficiencies of complex soft- ware systems. Existing software tools enable characterizing and measuring the amount of technical debt at selective granularity lev- els. by providing a computational model, they enable stakeholders to measure and ultimately control this phenomenon. Aims: In this paper we aim to study the evolution and characteristics of technical debt in open-source software. For this, we carry out a longitudi- nal study that covers the entire development history of several complex applications. The goal is to improve our understanding of how the amount and composition of technical debt changes in evolving software. We also study how new technical debt is in- troduced in software, as well as identify how developers handle its accumulation over the long term. Method: We carried out our evaluation using three complex, open-source Java applications. All 110 released versions, covering more than 10 years of development history for each application were analyzed using SonarQube. We studied how the amount, composition and history of technical debt changed during development, compared our results across the studied applications and present our most important findings. Results: For each application, we identified key versions during which large amounts of technical debt were added, removed or both. This had significantly more impact when compared to the lines of code or class count increases that generally occurred during devel- opment. However, within each version, we found high correlation between file lines of code and technical debt. We observed that the Pareto principle was satisfied for the studied applications, as 20% of issue types generated around 80% of total technical debt. Interest- ingly, there was a large degree of overlap between the issues that generated most of the debt across the studied applications. Conclu- sions: Early application versions showed greater fluctuation in the amount of existing technical debt. We found application size to be an unreliable predictor for the quantity of technical debt. Most debt was introduced in applications as part of milestone releases that expanded their feature set. likewise, we identified releases where extensive refactoring significantly reduced the level of debt. also discovered that technical debt issues persist for a long time in source code, and their removal did not appear to be prioritized according to type or severity.;Symposium;International Symposium on Empirical Software Engineering and Measurement;International Symposium on Empirical Software Engineering and Measurement;Software engineering;software evolution, software maintenance, technical debt, static analysis, open-source;9;;Yes;No;Yes;Yes;Experiment;Experiment;Validation Research;System-level structure quality issues;Yes;Yes;"general:""""
# 
approuch:""""
#
tools:""Sonarqube""
";No;No;-;-;-;-;-;-;Incomplete
109;Janes, Andrea, and Valentina Lenarduzzi 2020;;2020;Andrea Janes, Valentina Lenarduzzi;Towards an Approach to Identify Obsolete Features based on Importance and Technical Debt;2020;Many of today’s software systems are maintained over years or even decades. To ensure that software remains useful, new features have to be added or old features have to be adapted to respond to new or changed requirements. As time goes on, some of the features become obsolete, i.e., are not needed anymore. Typically, these features are not removed because of various reasons, e.g., because removing them might be considered too costly, the costs of keeping unused features is considered low, or because of the “sunk cost fallacy”, i.e., that a feature is considered worth to keep because of the previously invested resources (time, money or effort) to build it. The consequences of keeping unused source code can impact maintainability, technical debt, performance, and extensibility of the system. This can lead to lower development productivity and to a reduced innovation ability, consequently reducing competitiveness on the market. This paper aims to present an approach to identify features based on their value and on costs for keeping or removing them.;Conference;2020 46th Euromicro Conference on Software Engineering and Advanced Applications (SEAA);Euromicro Conference on Software Engineering and Advanced Applications;Software engineering;Feature importance, Technical Debt, Maintenance;5;;No;No;No;No;?;?;Philosophycal paper;System-level structure quality issues;Yes;No;"general:""""
# 
approuch:""""
#
tools:""Sonarqube""
";No;No;-;-;-;-;-;-;Incomplete
110;Maikantis, Theodoros, et al. 2020;;2020;Theodoros Maikantis,Angeliki Agathi Tsintzira,Apostolos Ampatzoglou,Elvira Maria Arvanitou,Alexander Chatzigeorgiou,Ioannis G Stamelos;Software Architecture Reconstruction via a Genetic Algorithm: Applying the Move Class Refactoring;2020;Modularity is one of the four key principles of software design and architecture. According to this principle, software should be organized into modules that are tightly linked internally (high cohe- sion), whereas at the same time as independent from other modules as possible (low coupling). However, in practice, this principle is violated due to poor architecting design decisions, lack of time, or coding shortcuts, leading to a phenomenon termed as architectural technical debt (ATD). To alleviate this problem (lack of architectural modularity), the most common solution is the application of a software refactoring, namely Move Class—i.e., moving classes (the core artifact in object-oriented systems) from one module to another. To identify Move Class refactoring opportunities, we em- ploy a search-based optimization process, relying on optimization metrics, through which optimal moves are derived. Given the ex- tensive search space required for applying a brute-force search strategy, in this paper, we propose the use of a genetic algorithm that re-arranges existing software classes into existing or new mod- ules (software packages in Java, or folders in C++). To validate the usefulness of the proposed refactorings, we performed an indus- trial case study on three projects (from the Aviation, Healthcare, and Manufacturing application domains). The results of the study indicate that the proposed architecture reconstruction is able to improve modularity, improving both coupling and cohesion. The obtained results can be useful to practitioners through an open source tool. whereas at the same point, they open interesting future work directions.;Conference;24th Pan-Hellenic Conference on Informatics;Pan-Hellenic Conference on Informatics;Informatics;Architecture reconstruction, coupling, cohesion, move class;5;;yes;yes;no;yes;Experiment;Experiment;Solution proposal;System-level structure quality issues;yes;no;"general:""""
# 
approuch:""""
#
tools:""proprietary""
";no;no;-;-;-;-;-;-;Incomplete
111;San Martín, Daniel, et al 2020;;2020;Daniel San Martín, Bento Siqueira, Valter Vieira de Camargo, Fabiano Ferrari;Characterizing Architectural Drifts of Adaptive Systems;2020;An adaptive system (AS) evaluates its own behavior and changes it when the evaluation indicates that the system is not accomplishing what it is intended to do, or when better functionality or performance is possible. MAPE-K is a reference model that prescribes the adaptation mechanism of ASs by means of high-level abstractions such as Monitors, Analyzers, Planners and Executors and the relationships among them. Since the abstractions and the relationships provided by MAPE-K are generic, other reference models were proposed focusing on providing lower level abstractions to support software engineers in a more suitable way. However, after the analysis of seven representative ASs, we realized the abstractions prescribed by the existing reference models are not properly implemented, thus leading to architectural drifts. Therefore, in this paper we characterized three of these drifts by describing them with a template and showing practical examples. The three architectural drifts of ASs are Scattered Reference Inputs, Mixed Executors and Effectors, and Obscure Alternatives. We expect that by identifying and characterizing these drifts, we can help software architects improve their design and, as a consequence, increase the reliability of this type of systems.;Conference;IEEE 27th International Conference on Software Analysis, Evolution and Reengineering (SANER);International Conference on Software Analysis, Evolution and Reengineering (SANER);Software engineering;"architectural drifts, adaptive system, mainte- nance
";11;;yes;no;yes;yes;Experiment;Experiment;Solution proposal;System-level structure quality issues;yes;no;"general:""""
# 
approuch:""""
#
tools:""proprietary""
";no;no;-;-;-;-;-;-;Incomplete
112;de Toledo, Saulo S., Antonio Martini, and Dag IK Sjoberg 2020;;2020;Saulo S. de Toledo, Antonio Martini, Dag I. K. Sjoberg;Improving agility by managing shared libraries in microservices;2020;Using microservices is a way of supporting an agile architecture. However, if the microservices development is not properly managed, the teams’ development velocity may be affected, reducing agility and increasing architectural technical debt. This paper investigates how to manage the use of shared libraries in microservices to improve agility during development. We interviewed practitioners from four large international companies involved in microservices projects to identify problems when using shared libraries. Our results show that the participating companies had issues with shared libraries as follows: coupling among teams, delays on fixes due to overhead on libraries development teams, and need to maintain many versions of the libraries. Our results highlight that the use of shared libraries may hinder agility on microservices. Thus, their use should be restricted to situations where shared libraries cannot be replaced by a microservice and the costs of replicating the code on each service is very high.;Conference;International Conference on Agile Software Development;International Conference on Agile Software Development;Software engineering;Cross-company study, Multiple-case study,Software quality, Qualitative analysis, Architectural technical debt ;9;;No;No;No;No;;;Validation Research;Complex architectural behavioral dependencies;yes;No;"general:""""
# 
approuch:""""
#
tools:""proprietary""
";No;No;-;-;-;-;-;-;Incomplete
113;Rademacher, Florian, Sabine Sachweh, and Albert Zundorf 2020;;2020;Florian Rademacher, Sabine Sachweh, Albert Zündorf;A modeling method for systematic architecture reconstruction of microservice-based software systems;2020;Microservice Architecture (MSA) is an approach to architecting service- based software systems, which aims for decreasing service coupling to enable independent service development and deployment. Consequently, the adoption of MSA is expected to particularly benefit the scalability, maintainability, and reliability of monolithic systems. However, MSA adoption also increases architectural complexity in service design, implementation, and operation. As a result, Software Architecture Reconstruction (SAR) of microservice architectures is aggravated. This paper presents a modeling method that systematizes SAR of microservice architectures with the goal to facilitate its execution. The method yields reconstruction models for certain architecture viewpoints in MSA to enable efficient architecture analysis. We validate the methodʼs applicability by means of a case study architecture and the assessment of its risk in technical debt using derived reconstruction models.;Conference;International Conference on Evaluation and Modeling Methods for Systems Analysis and Development;International Conference on Evaluation and Modeling Methods for Systems Analysis and Development;Systems Modeling;Microservice architecture, Software Architecture,Reconstruction,Model-driven engineering, Modeling languages ;12;;No;No;No;No;Experiment;Experiment;Solution proposal;Complex architectural behavioral dependencies;yes;No;"general:""""
# 
approuch:""""
#
tools:""proprietary""
";No;No;-;-;-;-;-;-;Incomplete
114;Larrucea, Xabier, Izaskun Santamaria, and Borja Fernandez‐Gauna 2020;;2020;Xabier Larrucea, Izaskun Santamaria, Borja Fernandez‐Gauna;Managing security debt across PLC phases in a VSE context;2020;Nowadays, security and safety aspects are two of the major concerns for any soft- ware system development, especially while developing safety critical systems. This is especially relevant for very small entities because they have a limited amount of resources for dealing with all these aspects at the same time. In addition, these sys- tems are highly regulated domains, and they involve a huge set of standards focused on safety and security‐related issues. Therefore, these small entities are not only fac- ing hurdles related to technical aspects but also from the so‐called technical debt when overarching a critical development. This paper extends the assurance cases approach by integrating security aspects within the life cycle, and it proposes a frame- work for managing the associated security technical debt for very small entities. A tool chain is outlined, and the approach is illustrated with an industrial use case.;Journal;Journal of Software: Evolution and Process;Journal of Software: Evolution and Process;Software engineering;assurance case, ISO/IEC 29110, safety, security, technical debt;14;;No;No;No;No;Experiment;Experiment;Solution proposal;System-level structure quality issues;Yes;No;"general:""""
# 
approuch:""security analysis""
#
tools:""proprietary""
";Yes;No;-;-;-;-;-;-;Incomplete
115;Raibulet, Claudia, Francesca Arcelli Fontana, and Simone Carettoni 2020;;2020;Claudia Raibulet1,Francesca Arcelli Fontana,Simone Carettoni;A preliminary analysis of self-adaptive systems according to different issues;2020;Self-adaptive systems dynamically change their structure and behavior in response to changes in their execution environment to ensure the quality of the services they provide. Self-adaptive systems are usually built of a managed part, which implements their func- tionality, and a managing part, which implements the self-adaptive mechanisms. Hence, the complexity of self-adaptive systems results also from the existence of the managing part and the interaction between the managed and the managing parts. The available evalua- tion approaches of self-adaptive systems focus on their performances, i.e., on the benefits (e.g., degree of autonomy, support for detecting anomalous behavior, adaptivity time, qual- ity of response) achieved through the self-adaptive mechanisms of the managing part. In this paper, we evaluate the quality of the design of self-adaptive systems (including the managed and the managing parts) as it is done in traditional software engineering. We are interested in the internal software quality of self-adaptive systems, as the existence of the managing part and its interaction with the managed part leads to a tightly coupled system. We analyze the self-adaptive systems through the detection of different issues such as architectural and code smells and the detection of design patterns. The smells provide some hints on possible design and implementation problems, and help software engineers to improve the quality of the systems. While, design patterns are usually indicators of the application of good prac- tices in the software development and allow to capture part of the design rationale. In this way, they can help software engineers to understand, reuse, and extend self-adaptive sys- tems. In this paper, we have considered the detection of 3 architectural smells, 18 code smells, and 15 design patterns in 11 self-adaptive systems written in the Java programming language. The results indicate that the 3 architectural smells, 9 out of the 18 code smells, and the 15 design patterns have been detected in all the analyzed self-adaptive systems. We also discuss the possible reasons behind the presence of these quality issues, and provide our lessons learned.;Journal;Software Quality Journal;Software Quality Journal;Software Quality;Self-adaptive systems,Software quality,Architectural smells,Code smells,Design patterns;31;;Yes;No;Yes;Yes;Experiment;Experiment;Validation Research;Architecture Smells;Yes;No;"general:""""
# 
approuch:""""
#
tools:""Arcan""";No;No;-;-;-;-;-;-;Complete
116;Tushar Sharma, Paramvir Singh and Diomidis Spinellis 2020;;2020;Tushar Sharma, Paramvir Singh, Diomidis Spinellis;An empirical investigation on the relationship between design and architecture smells;2020;"Context: Architecture of a software system represents the key design decisions and there- fore its quality plays an important role to keep the software maintainable. Code smells are indicators of quality issues in a software system and are classified based on their granular- ity, scope, and impact. Despite a plethora of existing work on smells, a detailed exploration of architecture smells, their characteristics, and their relationships with smells in other granularities is missing.
Objective: The paper aims to study architecture smells characteristics, investigate correla- tion, collocation, and causation relationships between architecture and design smells.
Method: We implement smell detection support for seven architecture smells. We mine 3073 open-source repositories containing more than 118 million lines of C# code and empirically investigate the relationships between seven architecture and 19 design smells.
Results: Wefindthatsmelldensitydoesnotdependonrepositorysize.Cumulatively,archi- tecture smells are highly correlated with design smells. Our collocation analysis finds that the majority of design and architecture smell pairs do not exhibit collocation. Finally, our causality analysis reveals that design smells cause architecture smells.";Journal;Empirical Software Engineering ;Empirical Software Engineering;Software engineering;Maintainability,Code quality,Code smells,Architecture smells,Design smells,Inter-smell relationships,Collocation,Correlation,Causality,Refactoring;49;;Yes;No;Yes;Yes;Experiment;Experiment;Validation Research;Architecture Smells;Yes;Yes;"general:""""
# 
approuch:""""
#
tools:""proprietary""
";No;No;-;-;-;-;-;-;Incomplete
300;Roberto Verdecchia,Patricia Lago,Ivano Malavolta,Ipek Ozkaya;;2020;Roberto Verdecchia,Patricia Lago,Ivano Malavolta,Ipek Ozkaya;ATDx: Building an Architectural Technical Debt Index;2020;"Architectural technical debt (ATD) in software-intensive systems refers to the architecture design decisions
which work as expedient in the short term, but later negatively impact system evolvability and maintainability.
Over the years numerous approaches have been proposed to detect particular types of ATD at a refined level
of granularity via source code analysis. Nevertheless, how to gain an encompassing overview of the ATD
present in a software-intensive system is still an open question. In this study, we present a multi-step approach
designed to build an ATD index (ATDx), which provides insights into a set of ATD dimensions building
upon existing architectural rules by leveraging statistical analysis. The ATDx approach can be adopted by
researchers and practitioners alike in order to gain a better understanding of the nature of the ATD present in
software-intensive systems, and provides a systematic framework to implement concrete instances of ATDx
according to specific project and organizational needs.";Conference;International Conference on Evaluation of Novel Approaches to Software Engineering;International Conference on Evaluation of Novel Approaches to Software Engineering;Software engineering;Software Architecture, Technical Debt, Software Analytics, Software Metrics, Software Maintenance;9;;Yes;No;Yes;Yes;Experiment;Experiment;Solution proposal;System-level structure quality issues;Complexity measures of files;version analysed;"general:""""
# 
approuch:""""
#
tools:""proprietary""
";No;No;-;-;-;-;-;-;Complete
301;Boris Perez;;2020;Boris Perez;A Semiautomatic Approach to Identify Architectural Technical Debt from Heterogeneous Artifacts;2020;Architectural Technical Debt (ATD) is a metaphor used to describe decisions taken by software architects to accomplish short-term goals but possibly negatively affecting the long-term health of the system. However, ATD doesn’t receive enough attention for the architect teams because it is hard to identify, to measure, to prioritize, and its value is related to long-term maintenance and evolution of a system. In this research, we propose a model-driven approach that focuses on building a binary classification model for ATD identification based on the information gathered from artifacts produced during architecture design. This model will allow software architects to support the managing of conscious and unconscious ATD in their software projects. This proposal focuses on TD at the architecture-level only without considering source code. The effectiveness of this proposal will be evaluated using case studies and expert interviews.;Conference;European Conference on Software Architecture;European Conference on Software Architecture;Software architecture;Architectural technical debt, Software architecture, Architectural technical debt management, Model-driven architecture;10;;Yes;Yes;No;Yes;Experiment;Experiment;Validation Research;System-level structure quality issues;System-level structure quality issues;release analysed;"general:""""
# 
approuch:""""
#
tools:""proprietary""
";No;No;-;-;-;-;-;-;Complete
302;Darius Sas, Ilaria Pigazzini, Paris Avgeriou, Francesca Arcelli Fontana;;2021;Darius Sas, Ilaria Pigazzini, Paris Avgeriou, Francesca Arcelli Fontana;The perception of Architectural Smells in industrial practice;2021;Architectural technical debt (TD) is the most significant type of TD in industrial practice. Our goals in this study were to better understand the phenomenon of architectural smells, help practitioners better manage them, and offer relevant support to researchers.;Journal;Journal IEEE Software;Journal IEEE Software;Software architecture;Software architecture, Technical Debt, Architectural Smells, Architectural Technical Debt;7;;No;Yes;No;Yes;survey;Survey;Validation Research;Architecture Smells;No;No;"general:""""
# 
approuch:""""
#
tools:""proprietary""
";No;No;-;-;-;-;-;-;Complete
303;Alvine B. Belle, Ghizlane El Boussaidi, Timothy C. Lethbridge, Segla Kpodjedo, Hafedh Mili, Andres Paz;;2021;Alvine B. Belle, Ghizlane El Boussaidi, Timothy C. Lethbridge, Segla Kpodjedo, Hafedh Mili, Andres Paz;Systematically reviewing the layered architectural pattern principles and their use to reconstruct software architectures;2021;Architectural reconstruction is a reverse engineering activity aiming at recovering the missing decisions on a system. It can help identify the components, within a legacy software application, according to the application's architectural pattern. It is useful to identify architectural technical debt. We are interested in identifying layers within a layered application since the layered pattern is one of the most used patterns to structure large systems. Earlier component reconstruction work focusing on that pattern relied on generic component identification criteria, such as cohesion and coupling. Recent work has identified architectural-pattern specific criteria to identify components within that pattern. However, the architectural-pattern specific criteria that the layered pattern embodies are loosely defined. In this paper, we present a first systematic literature review (SLR) of the literature aiming at inventorying such criteria for layers within legacy applications and grouping them under four principles that embody the fundamental design principles under-lying the architectural pattern. We identify six such criteria in the form of design rules. We also perform a second systematic literature review to synthesize the literature on software architecture reconstruction in the light of these criteria. We report those principles, the rules they encompass, their representation, and their usage in software architecture reconstruction.;Public Library;Cornel University;Cornel University;Software architecture;software architecture;30;;No;No;No;No;theorical method;Theorical;Other;System-level structure quality issues;No;No;"general:""""
# 
approuch:""""
#
tools:""proprietary""
";No;No;-;-;-;-;-;-;Incomplete
304;Saulo S.de Toledo, Antonio Martini, Dag I.K. Sjoberg;;2021;Saulo S.de Toledo, Antonio Martini, Dag I.K. Sjoberg;Identifying architectural technical debt, principal, and interest in microservices: A multiple-case study;2021;"Background: Using a microservices architecture is a popular strategy for software organizations to deliver value to their customers fast and continuously. However, scientific knowledge on how to manage architectural debt in microservices is scarce.
Objectives: In the context of microservices applications, this paper aims to identify architectural technical debts (ATDs), their costs, and their most common solutions.
Method: We conducted an exploratory multiple case study by conducting 25 interviews with practitioners working with microservices in seven large companies.
Results: We found 16 ATD issues, their negative impact (interest), and common solutions to repay each debt together with the related costs (principal). Two examples of critical ATD issues found were the use of shared databases that, if not properly planned, leads to potential breaks on services every time the database schema changes and bad API designs, which leads to coupling among teams. We identified ATDs occurring in different domains and stages of development and created a map of the relationships among those debts.
Conclusion: The findings may guide organizations in developing microservices systems that better manage and avoid architectural debts.

";Journal;Journal of Systems and Software;Journal of Systems and Software;Architectural Technical Debt;Cost of software, Cross-company study, Software quality, Software maintainability. Qualitative analysis;21;;Yes;Yes;No;Yes;survey;Exploratory case study;Evaluation research;System-level structure quality issues;No;No;"general:""""
# 
approuch:""""
#
tools:""proprietary""
";No;Yes;-;-;-;-;-;-;Complete
305;Lu Xiao, Yuanfang Cai, Rick Kazman, Ran Mo, Qiong Feng;;2021;Lu Xiao, Yuanfang Cai, Rick Kazman, Ran Mo, Qiong Feng;Detecting the Locations and Predicting the Costs of Compound Architectural Debts;2021;"Architectural Technical Debt (ATD) refers to sub-optimal architectural design in a software system that incurs high maintenance ``interest"" over time. Previous research revealed that ATD has significant negative impact on daily development. This paper contributes an approach to enable an architect to precisely locate ATDs, as well as capture the trajectory of maintenance cost on each debt, based on which, predict the cost of the debt in a future release. The ATDs are expressed in four typical patterns, which entail the core of each debt. Furthermore, we aggregate compound ATDs to capture the complicated relationship among multiple ATD instances, which should be examined together for effective refactoring solutions. We evaluate our approach on 18 real-world projects. We identified ATDs that persistently incur significant (up to 95% of) maintenance costs in most projects. The maintenance costs on the majority of debts fit into a linear regression model---indicating stable ``interest"" rate. In five projects, 12.1% to 27.6% of debts fit into an exponential model, indicating increasing ``interest"" rate, which deserve higher priority from architects. The regression models can accurately predict the costs of the majority of (82% to 100%) debts in the next release of a system. By aggregating related ATDs, architects can focus on a small number of cost-effective compound debts, which contain a relatively small number of source files, but account for a large portion of maintenance costs in their projects. With these capabilities, our approach can help architects make informed decisions regarding whether, where, and how to refactor for eliminating ATDs in their systems.";Conference;IEEE Transactions on Software Engineering ;IEEE Transactions on Software Engineering ;Software architecture;Maintenance engineering ,Software,Compounds,Computer architecture,History,Trajectory,Aggregates;30;;Yes;Yes;No;Yes;Experiment;Experiment;Validation Research;System-level structure quality issues;Architetural Root, Modularity Violation;version analysed;"general:""""
# 
approuch:""""
#
tools:""proprietary""
";code churn;version;-;-;-;-;-;-;Incomplete
306;Roberto Verdecchia, Philippe Kruchten, Patricia Lago, Ivano Malavolta;;2021;Roberto Verdecchia, Philippe Kruchten, Patricia Lago, Ivano Malavolta;Building and evaluating a theory of architectural technical debt in software-intensive systems;2021;"Architectural technical debt in software-intensive systems is a metaphor used to describe the “big” design decisions (e.g., choices regarding structure, frameworks, technologies, languages, etc.) that, while being suitable or even optimal when made, significantly hinder progress in the future. While other types of debt, such as code-level technical debt, can be readily detected by static analyzers, and often be refactored with minimal or only incremental efforts, architectural debt is hard to be identified, of wide-ranging remediation cost, daunting, and often avoided.
In this study, we aim at developing a better understanding of how software development organizations conceptualize architectural debt, and how they deal with it. In order to do so, in this investigation we apply a mixed empirical method, constituted by a grounded theory study followed by focus groups. With the grounded theory method we construct a theory on architectural technical debt by eliciting qualitative data from software architects and senior technical staff from a wide range of heterogeneous software development organizations. We applied the focus group method to evaluate the emerging theory and refine it according to the new data collected.
The result of the study, i.e., a theory emerging from the gathered data, constitutes an encompassing conceptual model of architectural technical debt, identifying and relating concepts such as its symptoms, causes, consequences, management strategies, and communication problems. From the conducted focus groups, we assessed that the theory adheres to the four evaluation criteria of classic grounded theory, i.e., the theory fits its underlying data, is able to work, has relevance, and is modifiable as new data appears.
By grounding the findings in empirical evidence, the theory provides researchers and practitioners with novel knowledge on the crucial factors of architectural technical debt experienced in industrial contexts.";Journal;Journal of Systems and Software;Journal of Systems and Software;Software engineering;Software engineering, Software architecture, Technical debt, Software evolution, Grounded theory, Focus group;23;;Yes;Yes;No;Yes;Experiment;Experiment;Validation Research;System-level structure quality issues;No;version analysed;"general:""""
# 
approuch:""""
#
tools:""proprietary""
";No;No;-;-;-;-;-;-;Complete
307;Sebastian Ospina, Roberto Verdecchia, Ivano Malavolta, Patricia Lago;;2021;Sebastian Ospina, Roberto Verdecchia, Ivano Malavolta, Patricia Lago;ATDx: A tool for providing a data-driven overview of architectural technical debt in software-intensive systems;2021;"Architectural technical debt (ATD) in software-intensive systems is mostly invisible to software developers, can be widespread throughout entire code-bases, and its remediation cost is often steep. In
recent years, numerous approaches have been proposed to identify, keep track, and ultimately manage
ATD. The variety of approaches available opens a new problem, namely how to gain an encompassing
overview of the ATD identified in a software-intensive system. With this paper we make available the
ATDx tool, an implementation of ATDx written in Python, designed in a plug-in fashion. ATDx is an
approach designed to provide a data-driven, intuitive, and actionable overview of the ATD present in
a portfolio of software projects. ATDx is based on third-party source code analysis tools, architectural
issue severity calculation via clustering, and aggregation of measurements into different architectural
technical debt dimensions. The ATDx tool allows users to automatically run the ATDx analysis, generate reports containing the ATDx analysis results, and is integrated with GitHub. In addition to the tool,
we provide two already implemented plugins, allowing users to run the ATDx tool out-of-the-box.
GitHub repository: https://github.com/S2-group/ATDx
Video: https://youtu.be/ULT9fgxuB7E";Conference;European Conference on Software Architecture;European Conference on Software Architecture;Software architecture;Software Engineering, Software Architecture, Technical Debt, Index, Tool;5;;Yes;No;Yes;Yes;Experiment;Experiment;Validation Research;System-level structure quality issues;Yes;Yes;"general:""""
# 
approuch:""""
#
tools:""proprietary""
";No;version;-;-;-;-;-;-;Complete
308;Saulo Toledo, Antonio Martini, Dag Sjoberg, Agata Przybyszewska, Johannes Frandsen;;2021;Saulo Toledo, Antonio Martini, Dag Sjoberg, Agata Przybyszewska, Johannes Frandsen;Reducing Incidents in Microservices by Repaying Architectural Technical Debt;2021;Architectural technical debt (ATD) may create a substantial extra effort in software development, which is called interest. There is little evidence about whether repaying ATD in microservices reduces such interest. Objectives: We wanted to conduct a first study on investigating the effect of removing ATD on the occurrence of incidents in a microservices architecture. Method: We conducted a quantitative and qualitative case study of a project with approximately 1000 microservices in a large, international financing services company. We measured and compared the number of software incidents of different categories before and after repaying ATD. Results: The total number of incidents was reduced by 84%, and the numbers of critical- and high-priority incidents were both reduced by approximately 90% after the architectural refactoring. The number of incidents in the architecture with the ATD was mainly constant over time, but we observed a slight increase of low priority incidents related to inaccessibility and the environment in the architecture without the ATD. Conclusion: This study shows evidence that refactoring ATDs, such as lack of communication standards, poor management of dead-letter queues, and the use of inadequate technologies in microservices, reduces the number of critical- and high-priority incidents and, thus, part of its interest, although some low priority incidents may increase.;Conference;Euromicro Conference on Software Engineering and Advanced Applications;Euromicro Conference on Software Engineering and Advanced Applications;Software engineering;Technical Debt, Architecture, Microservices, Case Study;10;;Yes;Yes;No;Yes;case study;Case study;Validation Research;System-level structure quality issues;Yes;Yes;"general:""""
# 
approuch:""""
#
tools:""proprietary""
";No;Yes;-;-;-;-;-;-;Complete
309;Klara Borowa, Andrzej Zalewski, Szymon Kijas;;2021;Klara Borowa, Andrzej Zalewski, Szymon Kijas;The influence of cognitive biases on architectural technical debt;2021;Cognitive biases exert a significant influence on human thinking and decision-making. In order to identify how they influence the occurrence of architectural technical debt, a series of semi-structured interviews with software architects was performed. The results show which classes of architectural technical debt originate from cognitive biases, and reveal the antecedents of technical debt items (classes) through biases. This way, we analysed how and when cognitive biases lead to the creation of technical debt. We also identified a set of debiasing techniques that can be used in order to prevent the negative influence of cognitive biases. The observations of the role of organisational culture in the avoidance of inadvertent technical debt throw a new light on that issue.;Conference;International Conference on Software Architecture;International Conference on Software Architecture;Software architecture;Software Architecture, Cognitive Bias, Technical Debt, Architectural Technical Debt, Architectural Decision Making;11;;Yes;No;Yes;Yes;survey;Survey;Validation Research;System-level structure quality issues;No;No;"general:""""
# 
approuch:""""
#
tools:""proprietary""
";No;No;-;-;-;-;-;-;Incomplete
310;Darius Sas, Paris Avgeriou, Ilaria Pigazzini, Francesca Arcelli Fontana;;2021;Darius Sas, Paris Avgeriou, Ilaria Pigazzini, Francesca Arcelli Fontana;On the relation between architectural smells and source code changes;2021;"Although architectural smells are one of the most studied type of architectural technical debt, their impact on maintenance effort has not been thoroughly investigated. Studying this impact would help to understand how much technical debt interest is being paid due to the existence of architecture smells and how this interest can be calculated. This work is a first attempt to address this issue by investigating the relation between architecture smells and source code changes. Specifically, we study whether the frequency and size of changes are correlated with the presence of a selected set of architectural smells. We detect architectural smells using the Arcan tool, which detects architectural smells by building a dependency graph of the system analyzed and then looking for the typical structures of the architectural smells. The findings, based on a case study of 31 open-source Java systems, show that 87% of the analyzed commits present more changes in artifacts with at least one smell, and the likelihood of changing increases with the number of smells. Moreover, there is also evidence to confirm that change frequency increases after the introduction of a smell and that the size of changes is also larger in smelly artifacts. These findings hold true especially in Medium–Large and Large artifacts.
";Journal;Journal of Software: Evolution and Process;Journal of Software: Evolution and Process;Software engineering;architectural smells, architectural technical debt, empirical study, software repository mining,technical debt, technical debt interest;21;;Yes;No;Yes;Yes;case study;case study;Validation Research;Architecture Smells;Yes;No;"general:""""
# 
approuch:""""
#
tools:""proprietary""
";No;No;-;-;-;-;-;-;Complete
311;Saulo De Toledo, Antonio Martini, ΩPhu Nguyen, Dag Sjoberg;;2022;Saulo De Toledo, Antonio Martini, ΩPhu Nguyen, Dag Sjoberg;Accumulation and Prioritization of Architectural Debt in Three Companies Migrating to Microservices;2022;Many companies migrate to microservices because they help deliver value to customers quickly and continuously. However, like any architectural style, microservices are prone to architectural technical debt (ATD), which can be costly if the debts are not timely identified, avoided, or removed. During the early stages of migration, microservice-specific ATDs (MS-ATDs) may accumulate. For example, practitioners may decide to continue using poorly defined APIs in microservices while attempting to maintain compatibility with old functionalities. The riskiest MS-ATDs must be prioritized. Nevertheless, there is limited research regarding the prioritization of MS-ATDs in companies migrating to microservices. This study aims to identify, during migration, which MS-ATDs occur, are the most severe, and are the most challenging to solve. In addition, we propose a way to prioritize these debts. We conducted a multiple exploratory case study of three large companies that were early in the migration process to microservices. We interviewed 47 practitioners with several roles to identify the debts in their contexts. We report the MS-ATDs detected during migration, the MS-ATDs that practitioners estimate to occur in the future, and the MS-ATDs that practitioners report as difficult to solve. We discuss the results in the context of the companies involved in this study. In addition, we used a risk assessment approach to propose a way for prioritizing MS-ATDs. Practitioners from other organizations and researchers may use this approach to provide rankings to help identify and prioritize which MS-ATDs should be avoided or solved in their contexts.;Journal;IEEE Access;IEEE Access;Software architecture;Architectural technical debt, microservices, software maintainability, cross-company study, qualitative analysis;24;;Yes;Yes;No;Yes;case study;Case study;Validation Research;System-level structure quality issues;Yes;Yes;"general:""""
# 
approuch:""""
#
tools:""proprietary""
";Yes;Yes;-;-;-;-;-;-;Incomplete
312;Roberto Verdecchia, Ivano Malavolta, Patricia Lago, Ipek Ozkaya;;2022;Roberto Verdecchia, Ivano Malavolta, Patricia Lago, Ipek Ozkaya;Empirical evaluation of an architectural technical debt index in the context of the Apache and ONAP ecosystems;2022;"Background: Architectural Technical Debt (ATD) in a software-intensive system denotes architectural design choices which, while being suitable or even optimal when adopted, lower the maintainability and evolvability of the system in the long term, hindering future development activities. Despite the growing research interest in ATD, how to gain an informative and encompassing viewpoint of the ATD present in a software-intensive system is still an open problem.
Objective: In this study, we evaluate ATDx, a data-driven approach providing an overview of the ATD present in a software-intensive system. The approach, based on the analysis of a software portfolio, calculates severity levels of architectural rule violations via a clustering algorithm, and aggregates results into different ATD dimensions.
Method: To evaluate ATDx, we implement an instance of the approach based on SonarQube, and run the analysis on the Apache and ONAP ecosystems. The analysis results are then shared with the portfolio contributors, who are invited to participate in an online survey designed to evaluate the representativeness and actionability of the approach.
Results: The survey results confirm the representativeness of the ATDx, in terms of both the ATDx analysis results and the used architectural technical debt dimensions. Results also showed the actionability of the approach, although to a lower extent when compared to the ATDx representativeness, with usage scenarios including refactoring, code review, communication, and ATD evolution analysis.
Conclusions: With ATDx, we strive for the establishment of a sound, comprehensive, and intuitive architectural view of the ATD identifiable via source code analysis. The collected results are promising, and display both the representativeness and actionability of the approach. As future work, we plan to consolidate the approach via further empirical experimentation, by considering other development contexts (e.g., proprietary portfolios and other source code analysis tools), and enhancing the ATDx report capabilities.";Journal; PeerJ Computer Science; PeerJ Computer Science;Software architecture;architectural technical debt;40;;Yes;Yes;No;Yes;Empirical study;Embedded case study in a large company;Evaluation research;System-level structure quality issues;yes;Yes;"general:""""
# 
approuch:""atdx""
#
tools:""proprietary""
";Yes;Yes;-;-;-;-;-;-;Incomplete