This article proposes REBEL (a semi-automated model-driven approach to manage aRchitectural tEchnical deBt (ATD)’s lifE cycLe. ), a semi-automated model-driven approach that exploits natural language processing, machine learning and model checking techniques on heterogeneous project artifacts to build a model that allows to locate and visualize the impact produced by the consciously injected ATD and its repayment strategy on the other architectural decisions. This proposal focus on ATD at architectural-level only without considering source code.The aim of this study was to develop a technique to identify Architectural Technical Debt in the form of a non-modularized component and to quantify the convenience of its repayment The identification [5] of ATD is therefore one of the main activities of software architects. In this paper, we seek to develop an automated solution that would support the identification of a specific ATD kind. The goal of this paper is therefore to develop a technique to estimate the convenience of refactoring the ATD. The main contributions are a measurement system for the identification of the Architectural Technical Debt according to the stakeholders’ goals, a mathematical relationship for calculating and quantifying its interest in terms of extra-effort spent in additional development and maintenance, and an overall decision framework to assess the benefit of refactoring. We also report context-specific results that show the estimated benefits of refactoring the specific case of Architectural Technical Debt. RQ – How can we identify and estimate, in a quantitative way, if a non-modularized component is worth refactoring? RQ1 – How can we identify if a component contains ATD in the form of lack of modularization? RQ2 – How can we estimate the current extra-cost paid as interest of the ATD? RQ3 – How can we estimate the long-term cost saved by modularizing the component?In this paper we propose and define a new index, more oriented to the evaluation of architectural violations. We describe in detail the index, called Architectural Debt Index, that we integrated in a tool developed for architectural smell detection. The index is based on the detection of architectural smells, their criticality and their history. The aim of our index is to evaluate the internal quality of a project in terms of: 1) the detected architectural smells, 2) their history, 3) their severity (the most critical ones) and 4) architecture design metrics. The index value of a project with a large number of smells and also critical smells (high severity) will be higher with respect to a project with less smells and low severity. Hence in this work, we aim to answer the following research questions: RQ1 How should a new index be formulated to more exhaustively evaluate architectural debt? RQ2 How can we estimate the severity of an architectural smell? RQ3 Is the new index based on architectural smell detection independent from another existing index based on code level issues?we conducted a case study where we identified flawed architecture relations and quantified their effects on maintenance activities. Using data from this project’s source code and revision history, we identified file groups where files are architecturally connected and participated in flawed architecture designs, quantified the maintenance activities in the detected files, and assessed the penalty related to these files. The objective of this case study is to understand if the detected architecture debt have a continuous impact on software evolution. That is, as software evolves with new change requests, determine whether files associated with poor architecture design are still change-prone and have high maintenance costs. RQ1: Are the files involved in an architecture root still change-prone during software evolution? RQ2: Whether and to what extent the file groups identified in architecture roots are associated with higher maintenance effort?In this study we measured architecture debt in two ways: 1) in terms of system-wide coupling measures, and 2) in terms of the number and severity of architecture flaws. In recent research it was shown that the amount of architecture debt has a huge impact on software maintainability and evolution. Consequently, reducing debt is expected to make software less costly and more amenable to change. This paper reports on a longitudinal study of a healthcare communications product created by BrightSquid Secure Communications Corp. The paper reports on the results of a longitudinal study of BrightSquid’s main software platform. In this study we performed an architecture analysis of the module structure of the platform before and after refactoring, with the goal of identifying and quantifying the architecture debt in the before and after states. To the best of our knowledge, this is the first real-world empirical study of architecture debt over a long period of time with the goal of demonstrating the benefit of improving a product’s software architecture by paying down architecture debt (through refactoring). RQ1: Do quantitative measures of architecture complexity change significantly before/after refactoring? RQ2: Do quantitative project measures of quality change significantly before/after refactoring? RQ3: Do qualitative perceptions of architectural quality change before/after and does this match the quantitative changes?In this paper, we propose a novel model, Active Hotspot (AH), that can be used to detect and monitor the emergence and evolution of software degradation by tracking how files and their relations are changed within each issue, such as adding a new feature or fixing a bug. In other words, we use issues as first-class entities of evolution, and data sources of our analysis [15]. Concretely, we first track and treat the source files that are modified to address multiple issues as seed files, calculate their architectural and semantic relations through four propagation pattern (which will be described in next paragraph) with other modified files, and form the minimal number of file groups, each of which is an active hotspot (or hotspot). To study how changes propagate from/to seed files, we manually examined a large number of relations among files modified to address various issues. We have identified 4 recurring and repetitive patterns over many projects: 1) dissemination— changes to one file propagate to multiple dependent files (one- to-many); 2) concentration—changes to multiple files cause another file to change (many-to-one); 3) domino—changes to one file cause ripple effects to a sequence of dependent files; and 4) scattershot—changes that scatter in multiple files without syntactic dependencies.In this work, we empirically investigate the ability of existing modularity metrics to substitute ANMCC as ATD indicators, through a holistic multiple case study on thirteen open source projects. The main contribution of this work is the empirical evidence supporting that two of the investigated modularity metrics, i.e., Index of Package Changing Impact (IPCI) and Index of Package Goal Focus (IPGF), have significant negative correlations with ANMCC – the ATD indicator. Thus, the two software modularity metrics (IPCI and IPGF) can be used as indicators of ATD of a system. The merit of using IPCI and IPGF as ATD indicators is that they can be automatically calculated using a single version of source code, while the calculation of ANMCC requires commit history information of a project which is not always available. The goal of this study, described using the Goal-Question-Metric (GQM) approach [2], is: to analyze modularity metrics for the purpose of evaluation with respect to their ability to act as substitutes of ANMCC, for indicating ATD, from the point of view of software architects in the context of OSS evolution. Based on the above mentioned goal, we have extracted two research questions (RQs): RQ1: Are there modularity metrics that correlate with ANMCC? RQ2: Which modularity metrics have the most accurate correlation with ANMCC?Since our goal was the development of a method, or else to design an artifact to be used in practice. To develop a process to identify and quantify ATD itensAlthough the concept of TD has been influential, it has until now largely been a metaphor. The dierences with real (financial) debt are crucial. A real debt always starts from a principal, and grows with a certain interest rate. How to quantify the principal and interest rate in software investments has been a challenge. Our goal is to advance the understanding and management of architectural debt, a type of technical debt, by quantifying it. We define the concept of architectural debt (ArchDebt) as a tuple consisting of: 1) a group of architecturally connected files, and 2) a model of the maintenance cost growth for such files. Based on this definition, we contribute an approach to automatically locate architecture debts. Once we locate each debt we model its growth using regression models. Our approach to identify ArchDebt has two parts. We first create a novel history coupling probability (HCP) matrix to manifest the probability of changing one file when another file is changed. Then we index file groups through the lens of 4 patterns of prototypical architectural flaws that have been shown to correlate with reduced software quality [21], namely hub, anchor-submissive, anchor-dominant, and modularity violation. Given an ArchDebt, we quantify the maintenance costs (approximated by bug-fixing churn) spent on the files involved in the debt. From the costs incurred in each release, we can model the growth trend using linear, logarithmic, exponential or polynomial regression models. These models represent coherent scenarios of stable, reducing, increasing, and fluctuating maintenance interest rates respectively. Finally, we rank the identified architectural debts according to the maintenance costs they have accumulated. We have evaluated our approach using seven Apache open source projects, and identified many instances (between 74 and 204) of ArchDebts in each project. The results show that a significant portion (from 51% to 85%) of the main- tenance e↵ort in each project is consumed by paying inter- est on these debts, and that non-trivial portions (20% to 61% ) of the maintenance e↵ort is consumed by just five ArchDebts, which represent a small portion of all error- prone files. Our evaluation also revealed that about half of the identified debts fit linear regression models, indicating a steady increase in the penalty that these debts incur. About 1/3, 1/10, and less than 1/10 of all debts fit polynomial, logarithmic, and exponential models respectively, indicating the interest rate trends of these debts can vary drastically. Finally, we qualitatively analyzed the design problems be- hind debts, and how these evolve over time. To evaluate the effectiveness of our approach, we investi- gate the following research question: RQ: Whether the file groups identified in ArchDebts generate and grow significant amount of maintenance costs? That is, are they true and significant debts? If the identified file groups only consume a small portion of overall maintenance efort, then they do not deserve much attention. Similarly, if the identified file groups cover a large portion of the system itself, it is not surprising if they also consume the majority of maintenance efort. In both cases, we cannot claim that they are debts worthy of attention.In this research we present an approach to automatically identify Architectural Technical Debt in Android applications. The approach takes advantage of architectural guidelines extraction and modeling, architecture reverse engineering, and compliance checking.It is a presentation about Sonargraph is a static analyzer tool with a focus on software architecture and metrics. The motivation to create Sonargraph came from the assumption that architectural debt (aka structural debt) is the most toxic form of technical debt.In this paper, we conduct an empirical study involving several organizations and several practitioners. The aim is to understand which ATD items are the most dangerous for accumulated interests. Moreover, it is important to understand what kind of interest is associated with the various ATD, both for their recognition during development and for the development of methods, tools, and measurements. In particular, we need to understand how compounded interest, the costliest interest, is accumulated in practice. We therefore answer the following research questions: RQ1: What are the most dangerous classes of ATD in terms of generated interest? RQ2: What kind of interest is triggered by different classes of ATD? RQ3: Are there socio‐technical anti‐patterns causing the ATD and its interest to increase over time causing the accumulation of compounded interest? RQ4 How can contagious debt and, therefore, the accumulation of compounded interest, be identified and stopped? The main contributions of the paper are • We have qualitatively developed and validated (through multiple sources) a taxonomy of effortful ATD classes. • We link specific interests to specific classes of ATD by identifying recurring sociotechnical phenomena and consequent extra activi- ties that could lead to extra costs • We have conceptualized, defined, and found empirical evidence of, an important phenomena of ATD, contagious debt; this is related to the occurrence of sociotechnical chains of events (that we call vicious cycles) responsible for the increment of interest and that potentially lead to the accumulation of compound interest. We have identified propagation factors, responsible for making the ATD contagious. By monitoring the growth of such factors, the practitioners can proactively avoid the accumulation of compound interest.In this paper, we provide our experience report in using three known tools to capture information that can be useful to identify and evaluate the architectural debt of an application. To evaluate 3 tools (Sonargraph, SonarQube and Fusion) to check architectural debt. This paper aims to describe our experimentation using these tools, by ana- lyzing diferent systems. We also report the results obtained analyzing an application we developed for the crawling and analysis of open source projects [1]. We focus our attention on comparing the following architectural evaluation issues: 1) the Quality Indexes the tools compute; 2) the Results Inspection capabilities of the data the tools provide; 3) the Data extracted by the tools on the same system.To overcome the shortcomings of source code analysis- based ATD identification approaches, we propose to identify ATD based on ADs made during the architecting process and change scenarios for software maintenance and evolution. An AD is a design decision that affects the architecture design space for a target software system [5]. A change scenario is a maintenance or evolution task to be performed in the software system. The proposed approach takes ADs and change scenarios as input, and then comes up with ATD items that are caused by the ADs or negatively impact the change scenarios. To validate our proposed approach, we conducted an industrial case study which evaluates the effectiveness and usability of identifying ATD using this approach. The results show that the approach is useful and easy to use, and it supports release planning and ATD interest measurement. RQ1: How effective is the approach? RQ1.1: How useful is the ATD identification approach for identifying ATD in the project? RQ1.2: How appropriate is the granularity of the change scenarios used in the ATD identification approach for ATD interest measurement in the project? RQ1.3: How helpful are the identified ATD items to the release planning of the project? RQ2: How easy is it to execute the ATD identification approach for the project?The study of such subject would also compensate the lack, in ASD (Agile Software Development) frameworks, of activities for enhancing agility in the task of developing and maintaining software architecture in large projects. In the context of large-scale ASD, the research questions that we want to inform are: RQ1: What factors cause the accumulation of ATD? RQ2: What are the current trends in practice in the accumulation and recovery of ATD over time? The main contributions of the papers are therefore: - A taxonomy of the causes for ATD: we provide the factors for the explanation of the phenomena such as accumulation and recovery of ATD. These factors might be studied and treated separately, and offer a better understanding of the overall phenomenon. - A qualitative model of the trends in accumulation and recovery of ATD over time. Such model: -- Shows the strictly increasing trend of ATD accumulation and how it eventually reaches a crisis point. We connect such phenomenon to the different factors and their influence on such accumulation. -- Helps identifying problem areas and points in time for the development of practices that would 1) avoid accumulation of ATD and/or 2) ease the recovery of ATD. Such practices would be aimed at delaying the crisis point.We have conducted a case study in a large company, analyzing a case of refactoring a component to achieve modularity. We report a comparative study of a refactored against a non-refactored component. We found that the modularization would be repaid in several months of development and maintenance. We present a method to calculate the effort saved by the modularization and an equation for calculating and quantifying the development and maintenance benefits of refactoring. RQ – How can we estimate, in a quantitative way, the benefits of modularizing a component? We have conducted a case study in a large software company: we have studied a case in which the functionality of a component was modularized and used by new applications. By comparing the development and maintenance effort between the two solutions, we developed a formula quantifying the refactoring benefits.In this study we aim at answering the fol- lowing RQs: – RQ 1: How do AS help practitioners in identifying ATD? – RQ 2: How do practitioners prioritize ATD revealed through AS? – RQ 2.1: How is the AS’s negative impact (interest) perceived by the practitioners? – RQ 2.2: What is the refactoring cost (principal) of AS perceived by the practitioners? By answering RQ1, we aim at understanding if AS are useful to automati- cally identify ATD in industrial projects. Answering RQ2 means answering the combination of RQ2.1 and RQ2.2: understanding what negative impact is gen- erated by the ATD and what cost of refactoring is required. This would help identifying which AS are more critical for the practitioners to prioritize. The objectives of the case-study were: automatically identify the AS in the industrial projects (RQ1) evaluate the output in terms of negative impact (RQ2.1) and cost of refac- toring (RQ2.2), to prioritize the ATD.In this paper, we first discuss the concept of architecture debt and how this debt grows in virtually every software-intensive project. Next we propose a methodology for developers to monitor the health of a project’s architecture through an analysis of the development artifacts that a project produces. Our objective is to monitor and manage architecture debt by leveraging an architecture model that we proposed recently, called the Design Rule Space (DRSpace). We use DRSpaces to split a complex system into smaller subsystems based on features, patterns, refactoring targets, etc., so that we can monitor and analyze the evolution and interaction of each subsystem separately. We also employ a recently proposed architectural metric—Decoupling Level—to quantitatively monitor changes in a project’s overall level of architecture maintainability.To remedy this situation we have applied following strategy to identify and quantify architecture debts to a system that SoftServe was maintaining, and justified the refactoring of architecture problems with an economic analysis. We first used the Design Rule Space (DRSpace) analysis approach [30] to precisely locate architecture debts in a few clusters of files. After that, we visualized the architecture flaws among these files, pointing out to the architects how these flaws propagate errors. After these flaws, (architecture hotspots), were confirmed by the architects, we extracted data from the development process to quantify the penalty these debts were incurring, estimated the potential benefits of refactoring, and made a business case to justify refactoring. When we started working together SoftServe had already been maintaining their system, which they inherited from another company, for almost two years. They were actively trying to improve the maintainability of the code base, remove dead and cloned code, and rationalize its architecture, and they had already made some progress in this direction. They had been working with commercial tools, such as SonarQube1, Understand2 and Structure 1013, to help identify problematic areas in the system. What the DRSpace process offered them was, however, quite different than those commercial tools: we offered them explicit (and automated) identification of problem areas in the architecture, along with explanations for why these areas were problematic. Unlike other tools that report a list of individual problematic files, We reported these architecture debts in the form of 3 to 6 groups of architecturally related files, and the architecture flaws among them can be visualized. This analysis revealed significant architecture issues not detectable by other tools, and allowed them to plan refactoring strategies to address these problems We conducted a case study as a means of achieving two objectives. First, we wanted to understand if our architecture hotspot analysis process could identify problems—architecture debts—that industrial practitioners consider to be real, signif- icant, and worth fixing. Second, we wanted to understand if it is possible quantify these architecture debts, based on readily available project data, to help these practitioners make rational refactoring decisions. RQ1: According to opinions of SoftServe’s architects, are the set of architectural issues that we reported truly problematic issues—that is, architecture debts? RQ2: How do the results returned by the Titan tool chain differ from the files reported as sources of technical debt by other tools SoftServe is using, such as SonarQube? RQ3: Is it possible to quantify the return on investment of removing architecture debts? In other words, is it possible to determine the penalty incurred by the debts and the expected benefits if the debts are removed, and compare this with the costs of refactoring?According to a recent study carried out by the same authors of this paper [6], the prioritization of ATD with respect to feature development is an important activity in order to balance the short-term value delivery and the long-term responsiveness of a company. Not prioritizing ATD might lead to software development crisis followed by big refactoring activities preventing the continuous delivery of features [6]. Although such prioritization seems a critical activity, the recent mapping study found a gap in the current scientific knowledge: “More industrial studies are needed to show how to prioritize a list of TD items to maximize the benefit of a software project and which factors should be considered during TD prioritization in the context of commercial software development.” [3]. We therefore intend to fill such gap by exploring how the prioritization activity is performed and what are the information needs between the key actors in such activity: the software architects and the product owners (POs). We especially investigated large Scandinavian companies developing embedded software and employing Agile software development. Our research questions are the following: RQ1: What is the information needed by product owners and architects to prioritize ATD with respect to feature development? RQ2: What are the differences between architects and product owners when prioritizing ATD with respect to features?In order to make predictions about software design depend- encies, a particular graph-based approach is Social Networks Analysis (SNA), which refers to a strategy for analysing social structures through network and graph theories [16]. SNA studies to what extent the evolution of a network can be modelled by using features intrinsic to the network [16]. One particular task is known as Link Prediction (LP), and aims at inferring missing links between two nodes in a network based on the observable interactions (or links) amongst nodes and node attributes, when available. Due to its relevance in different domains, several techniques have been proposed to solve the LP problem, usually based on graph structural features that assess similarity between pairs of nodes. As software architectures comprise components that interact with each other, it is natural to model architectures as graphs. In fact, a module view can be modelled as a dependency graph, in which nodes represent modules and directed edges represent usage relations. These relations can be inferred from the code via static analysis. However, software design networks could have a different dynamic from traditional social networks. The motivations for this research come from the lack of studies investigating the potential of SNA not only for describing software design structures, but also for predicting their evolution or properties. The analysis then would not just be limited to characterising design elements (e.g. packages, components) and their dependencies, but to how design in- formation can be used to provide insights about future system versions. This knowledge would support predictive capabilities for architects’ decisions regarding system refactorings or other strategies for dealing with technical debt in the system. In this context, the goal of this research is to use SNA techniques along with information from current and past design structures of a system for inferring possible architectural smells in terms of configurations of design dependencies. RQ1. How do architectural smells evolve over system versions, in terms of increasing or decreasing their de- pendency configurations? RQ2. What criteria are useful for assessing similarity of design elements with respect to link prediction? RQ3. Can past system versions affect, and improve the predictions of, the design structure of a future version? RQ4. To what extent Machine Learning techniques can aid in the prediction of architectural smells?In this paper we’ll endeavor to provide a foundation for incurring and managing prudent, deliberate, intentional technical debt. We use software architecture as a means to identify and monitor architectural technical debt, or architectural debt, so that re-architecting and refactoring decisions can be made in a timely manner. We illustrate our approach by describing an ongoing development effort: the Disaster Response Network-Enabled Platform (DRNEP).Present a tool called DV8 and theirs features. The objective of DV8 is to measure software modularity, detect architecture anti-patterns as technical debts, quantify the maintenance cost of each instance of an anti-pattern, and enable return on investment analyses of architectural debts. Different from other tools, DV8 integrates data from both source code and revision history. We now elaborate on each of DV8’s capabilities.In this study, we investigate the relation between package-level modularity metrics and technical debt principal, as measured by a state-of-the-art tool, namely SonarQube that is based on the SQALE model [11]. SonarQube is an Open Source Software (OSS) platform for the continuous inspection of code quality. SonarQube assesses the technical debt of a software system at the source code level by counting violations of best practices (e.g., Removal of Unused Private Fields, Constructors Should be Used for String Initialization, or @Override Should be Used for Overriding Methods) and estimating the time needed to resolve them. The platform supports a plethora of programming languages and it can offer detailed reports re- garding duplicated code, coding standards, unit tests etc. Nevertheless, based on the current TD calculation model it is not clear if the violations that SonarQube can capture are also (di- rectly or indirectly) related to architecture violations, or at least, if the provided measure is correlated with violation of some architecture best practices (e.g. modularity). The main research question of this paper is: “Is TD principal as quantified by SonarQube related to the lack of software modularity? RQ1: Is TD principal related to package cohesion? RQ2: Is TD principal related to package coupling?It is identify ATD in Architectural high level view and visualise ATD interest based on performance effort of intercommunication components in a Automotive Industry that use ECU (Eletronic Component Unit) to control automotive components. According to a recent mapping study [7], ATD is studied to some extent in literature, but there are still several gaps when practically managing such kind of debt: the interest (impact) often remains hidden, which makes it difficult for the stakeholders to decide if the refactoring of ATD should be performed or not. Many studies focus on the maintainability impact that an ATD item has, but not on other quality attributes, such as performance. Another gap is that ATD is studied at a rather general level, but there is a lack of empirical studies showing what ATD is and how it is managed in different contexts, for example in the automotive industry. Finally, there is little research about how to visualize ATD and its interest (impact), especially in a combined view. Based on the previous gaps, we have constructed the fol- lowing three research questions: RQ1 What is a typical ATD item for the automotive industry? RQ2 What is the impact, or interest, of such ATD item? RQ3 How can the ATD and its interest be visualized together to aid the stakeholders’ awareness? In this study, we have explored how to visualize the effi- ciency interest caused by architectural violations in a concrete case. We have identified, together with the architects at VCG, relevant ATD items present at the design level but forbidden at the architecture level. Then we have investigated the interest in terms of efficiency (a key quality for cars) due to the existence of such ATD items. We have constructed a visualization tool based on the literature state of the art and the ATD, and we have validated the tool and visualization with architects at the company.It is evaluate 5 tools to check Technical Debt Index generated by the each tool. Technical Debt/Severity, Deficit Index, that offers an evaluation of the overall quality of an analyzed project. In the paper, with the term Technical Debt Index (TDI), we refer to any kind of quality index computed by the tools. These indexes are derived in different ways and take into account different features. We focus our attention on the TDI provided by known tools, with the aim to understand what exactly each index takes into account, what the value of the index represents, and its completeness w.r.t. the information that can be exploited to estimate Technical Debt. With these aims, we try to answer the following questions: Q1 How are the quality indexes the tools provide exactly computed? Which features do they take into account? Q2 Which index does take more into account the archi- tectural issues and in which way? Q3 Which are the features not provided or taken into account by the indexes? We decided to consider in this paper five tools that provide some kind of TDI: CAST, inFusion, Sonargraph, SonarQube and Structure101.Evaluate two systems with different architectural structure comporting the coupling among components about defect related activity. We address this gap by analyzing the relationship between system architecture and maintenance costs for two software systems of similar size, but with very different structures; one has a “Hierarchical” de- sign, the other has a “Core-Periphery” design. We measure the level of system coupling for the 20,000+ components in each system, and use these measures to predict maintenance efforts, or “defect-related ac- tivity.” We show that in both systems, the tightly-coupled Core or Central components cost significantly more to maintain then loosely-coupled Peripheral components. In essence, a small number of compo- nents generate a large proportion of system costs. However, we find major differences in the potential benefits available from refactoring these systems, related to their differing designs.In this study, we propose an approach to study the evolution of AS detected by an open source tool named Arcan [5], by tracking individual smell instances and measuring the evolution of the properties of each detected instance. We have detected almost 150.000 unique smell instances in over 500 versions across 14 open source Java projects. We have performed four types of analyses: a generic data mining analysis to have a better understanding of the data, a trend analysis to understand the evolution of the smells over time, a correlation analysis to identify possible correlations among the smell characteristics1 considered, and a survival analysis to document their probability to persist within the system. The focus of this study is on the architectural smells known as instability AS [6];Hence, in this paper we investigate two measures that can pro- vide a support to the developers/maintainers for the evaluation of the most critical architectural smells. The first one is the criticality associated to each specific type of AS. It is based on the metrics used to detect each smell (described in Section 3.2.2). The second one is called PageRank, evaluated according to each architectural smell instance found in a project. Through the PageRank it is possible to quantify the relevance of the part of the project affected by the smell (see Section 3.2.3). In this way, it is possible to identify the architectural smells which are more central in a project (if many parts depend on the part where the architectural smell is involved) and with a higher impact on the project with respect to those that can be considered more peripheral [16]. In this paper, we exploit the Arcan tool [1] to detect three archi- tectural smells (Unstable Dependency, Cyclic Dependency, Hub- Like Dependency) and the Gephi tool1 to evaluate the PageRank of the smells in six projects. We can find cases where the criticality of an architectural smell is evaluated as high, but the PageRank is low, or vice versa. We can find that the PageRank value is significant for a kind of smell, for example for Cyclic Dependency smell, and less for others. Hence, through the investigation described in this paper we aim to provide preliminary answers to the following Research Questions (RQ): (RQ1) If we consider the PageRank and criticality measures of AS, can we observe the same trends between the values of the two measures for each AS? (RQ2) How does the PageRank measure behave in the case a component is affected by different types of AS simultaneously? To answer the above questions we analyze and compute in six open source Java projects (Ant, haddop, POI, TOMCAT, FireBugs and JUniti): • the architectural smells and their criticality (Section 4.1); • the PageRank of the architectural smells (Section 4.2); • the possible relations existing between architectural smell criticality and PageRank for RQ1 (Section 4.3.1.); • the PageRank of the components affected by multiple archi- tectural smells for RQ2 (Section 4.3.2)In this paper we study the evolution of Unix along the FreeBSD lineage from a software architecture perspective. While there have been studies on how Unix evolved (see Section 2), these have mostly focused at the source code level and were limited to the kernel. On the contrary, we turn our attention to the system architecture and study a) the core architectural design decisions across the main releases, and b) the evolution in the number of the system’s features (obtained from the Unix reference documentation) and in the code’s complexity. The former entails qualita- tive analysis, while the latter quantitative. These analyses subsequently lead to forming an initial theory on the archi- tecture evolution of large and complex operating systems, regarding their form, pace, driving forces, as well as the accumulation of architectural technical debt. The goal of this study, stated here using the Goal-Question- Metric (GQM) approach [68], is to “analyze the Unix oper- ating system for the purpose of evaluation and characteri- zation of its architecture evolution with respect to its main architecture design decisions, size and complexity from the point of view of software developers in the context of the Unix ecosystem”. The aforementioned goal can be achieved by answering the following research questions: RQ1 What are the main architectural design decisions along the major releases of the system? RQ2 How did complexity and the number of features evolve along the main releases of the system?Our study explores the usage of agreed upon weaknesses (CWEs) as a basis for quantifying TD associated with security issues. Our motivation stems from the fact that a large community effort has already generated a lot of data informed by experts from both industry and academia. Specifically, the Common Weakness Scoring System (CWSS) [17, 22] already provides a mechanism for prioritizing weaknesses according to relevant importance and context. CWSS follows the steps of the Common Vulnerability Scoring System (CVSS), with the former focusing on weaknesses rather than vulnerabilities. This is an important distinction because a weakness is “a shortcoming or imperfection in the software code, design, architecture, or deployment that, could, at some point become a vulnerability”[2] and vulnerabilitie are manifestations of weaknesses at runtime. Thus, since TD is a phenomenon that is best observed during design (i.e. tradeoffs), then CWSS is the appropriate scoring mechanism that should be leveraged. CWSS offers different approaches to calculate a weakness score, of which the Aggregated and Generalized methods offer a one-to-one mapping with our implementation [9] of the Quamoco hierarchical quality model. Further, since TD is more relevant to design issues, as opposed to code level (non- design) issues [18], we only focus on those rules (i.e., CWEs) associated with design at the architectural level [21]. Thus, our goal in this position study is to explore an approach that uses CWSS scores relevant to architectural decisions to help rank TD issues associated with security weaknessesThere are many different types of TD (such as Architectural TD, Requirement TD, Test TD, Code TD), which differ in the degree of their negative impact and consequently cause various levels of wasted time during the software development process. Several professional roles participate in the software development process, and could possibly be affected by TD in diverse ways. Furthermore, as the software ages, different types of TD could have varying negative effects and could possibly generate a dissimilar distribution of extra time spent on different activities. However, little knowledge and few supporting tools are available to measure the extent of TD within a system and, in addition, the time spent on TD related issues is not made explicitly visible and measurable. Without such knowledge, software development organizations do not know the interest that they are paying on the debt, and therefore they might not give TD management the necessary attention. We will answer the research questions by using survey data based on software professionals’ perceptions. All survey respondents were experienced in software development, and therefore, their estimates were likely to be formed by what they have heard, observed, and experienced at their workplaces. To the best of our knowledge, there are no studies quantifying the interest in terms of how much time (observed, measured or estimated) is wasted due to TD and how this wasted time varies in relation to the system age and its impact on a range of professional software roles. To do a survey and interviews to check the following questions: RQ1. How much of the overall development time is wasted because of Technical Debt? RQ2. What kind of Technical Debt Challenges generates the most negative impact? RQ3. What are the various activities on which extra-time is spent as a result of Technical Debt? RQ4. In what way does the age of the software system affect the questions stated in RQ1-3? RQ5. In what way are the different professional software roles affected by the questions stated in RQ1-3?To check how practitioners percept Technical Debt in Embedded Systems about Quality Attributes. RQ1: What is the relationship between the expected lifetime of components and technical debt? RQ2: What types of technical debt (e.g., code, architectural, etc.) are more frequently occurring in embedded systems? RQ3: What is the significance of building maintainable software systems (with low TD) compared to satisfying other quality attributes? Case study in seven technology companies: Telecomunication Automotive Mobile Sensors Priting Smart Manufacturing Media DevicesThe main goal of the paper is to check how is the process of Technical Debt tracking in Large Software Companies. The authors made a survey with practitioners in large software companies, and multiple case study in 3 large software companies in Scandinavia area. The questions: RQ1 How much of the software development time is estimated to be employed in managing TD? It is also important to understand how a TD tracking process is introduced and implemented in large software companies.We therefore aim at answering the following RQs: RQ2 To what extent do software organizations track TD? RQ3 How do software organizations introduce a TD tracking process? RQ4 What are the initial benefits and challenges when large organizations start tracking TD?To provide empirical insights into requirements volatility from SW architects’ point of view, an industrial case study was conducted to explore requirements volatility in the context of SW architecture design. Fifteen SW architects involved in architecture design were interviewed for the case, the objective of which was to identify challenges that SW architects face due to requirements volatility and to propose means to address those challenges. The following research questions were derived from the objectives of the case. RQ1: What are the factors that cause requirement volatility? RQ2: What challenges does requirements volatility pose to SW architecture design? RQ3: What are means to address the identified challenges in SW development?This paper aims at improving software management by shedding light on the current factors responsible for the accumulation of Architectural Technical Debt and to understand how it evolves over time. In this paper we aim at filling such current gaps by investigating, in several companies, the overall phenomenon of accumulation and refactoring of ATD. The study of such subject would also contribute to ASD frameworks, by highlighting activities for enhancing agility in the task of developing and maintaining software architecture in large projects [5]. In the context of large-scale ASD, our research questions are: RQ1: What factors cause the accumulation of ATD? RQ2: How is ATD accumulated and refactored over time? RQ3: What possible refactoring strategies can be employed for managing ATD?In this paper, we report on our investigation of using DRSpaces to reveal the architectural impact of bug-prone files. In this paper, we show, using DRSpaces, that we can automatically identify architectural flaws that contribute to bug-proneness in a software project. This is achieved by automatically identifying a minimal set of DRSpaces that connect the top bug-prone files in the system. We call these DRSpaces Architecture Roots (ArchRoots). We hypothesize that the ArchRoots have deep-seated and enduring impacts on the bug-proneness of a project. They propagate bugs among files, making bugs hard to eradicate, and consequently causing maintenance costs to increase over time. As we will show, developers can not systematically reduce the bug rate of a project without fixing these ArchRoots firstWe formulated three research questions to set a direction and scope for our study: RQ1: How do software professionals structure the general evolvability assurance activities for Microservices and for what reasons? RQ2: What tools, metrics, and patterns do software professionals use for assuring the evolvability of Microservices and with what rationales? RQ3: How do software professionals perceive the quality of their Microservices and assurance processes and what parts are seen as challenging?There are several practical software quality models and tools that have been recently developed and that generally include an automated measurement of technical debt [7]. However, by default, the measured technical debt may not be an accurate measure of product quality issues [8]. While some technical debt is unavoidable [9], a large survey of software engineers and architects across multiple organizations provides a practical view of the causes and sources of avoidable technical debt [5]. Their results indicate that architectural decisions, overly complex code, and lack of code documentation are the top three avoidable sources of technical debt in practice.Analyse a set of application from Cast database system tWe analyzed these applications us- ing CAST’s Application Intelligence Platform (AIP),7 which analyzes an en- tire application using more than 1,200 rules to detect violations of good ar- chitectural and coding practice. We drew these rules from software engi- neering literature, repositories such as the Common Weakness Enumeration (CWE; cwe.mitre.org), online discus- sion groups of structural quality prob- lems, and customer experience as re- ported from defect logs and application architects. As an example, security- related violations would include SQL injection, cross-site scripting, buffer overflows, and other violations from the CWE.The purpose of this study is to explore a method for quantifying an estimate of the Technical Debt within a business application. Such studies are needed to help IT organizations make visible the costs and risks hidden within their application portfolio, as well as establish a benchmark for making decisions about investments in application quality, and especially structural quality.Two insights that we come out of our work practice with designing/architecting/coding in real production world cloud computing services or applications/resources are: security risk, threat/problem. Context milieu circumstance, perspective framework stages participates with a big role in cloud service or resource security design and architecture. Security risk, threat, attack, issues, problem patterns are anticipated excellent elucidation, but purely on whence we relate the situation and apply them in fitting right security design context and the problem/risk with measure.Our goals in this paper are: (1) To advocate for the necessity to study novel and lightweight approaches to manage scalability debt in open systems. And, (2) To provide a first preliminary study of a lightweight analysis method that can support managing scalability debt in open systems. The subsequent RQ is: How can we identify, estimate and prioritize scalability debt in open systems?As preliminary work for our investigation, we identify the architectural divergences that have occurred over time in ArgoUML. We achieve this by obtaining and contrasting the concrete and conceptual architectures of the system based on available documentation and the source code of the project. We replicate techniques from previous work [3], [15], [7]; where alongside the goals and findings of each study, their authors were able to expose many unexpected and missing dependencies between subsystems in an architecture (archi- tectural divergences). Bowman and Brewster [3] pointed out that many of the unexpected dependencies they found in Linux could not be explained by rationale and their occurrence is due to developers bad practices or expediency. Since identifying SATD exposes problems acknowledged by developers, we investigate if SATD can be a good indicator of said unwanted links between subsystems. We examine the following research questions for our study: RQ1 - How many architectural divergences can be traced to SATD comments? RQ2 - How many architectural divergences can be fixed by addressing SATD?Service-Based Systems (SBSs) promised to bring a number of structural benefits to software maintainability, which has been sup- ported by several studies (e.g. [16, 18]). In recent years, an agile, light-weight, and DevOps-focused service-oriented variant called Microservice-Based Systems (μSBSs) gained popularity and is now trying to renew this promise for a second time. While service orien- tation can bring several benefits, the different levels of abstraction make it also important to revise and adapt design, development, and quality control mechanisms, as for example reported by Voelz and Goeb [23]. Especially in the context of microservices, technological heterogeneity and decentralization of control can have negative impacts on the maintainability of a composed application, if not treated appropriately. We therefore created a survey for software professionals to gain insights into their notion of maintainability assurance, more specif- ically a) their used processes, tools, and metrics, b) potentially different treatment of SBSs and μSBSs w.r.t. maintainability control, and c) influences on their satisfaction w.r.t. their maintainability- related actions. Note that while we are aware of existing differences between Service-Oriented Architecture (SOA) and Microservices [5], we focused on their similarities in this paper and explicitly chose the term “Service-Based Systems”, which is not as connected to enterprise-wide governance, standardization, and centralization as SOA. This leads to the following research questions for our survey: RQ1: What processes, tools, and metrics are used in the industry to measure and control maintainability? RQ2: Is the usage of maintainability control different for Service- or Microservice-Based Systems? RQ3: What correlations exist between applied maintainability controls and participants’ overall view of maintainability in their project?Architectural decisions shape the properties of software systems and may put quality [7] and buildability [8] at risk. Architects may represent a varied attitude towards such architectural risks. For example, some may take risks eagerly, in an attempt to exploit opportunities to improve some of the software quality attributes, while others may be reluctant to take any risk. The general research question is how architects’ attitude towards risk influences the decision-making process. This translates into following research questions: RQ.1. How are architectural risks taken? RQ.2. Which aspects of the architectural decision- making process are influenced by architects’ attitude towards risk? RQ.3. How should architects’ attitudes towards architectural risks be classified? RQ.4. Does the proposed classification reflect real world cases?To flesh out the above-mentioned objective, three main RQs were formulated. RQ1: Are there any community smells emerging in the process of software architecting? RQ2: Provided that architectural community smells do exist, can the extent of the impact for reported community smells be measured? RQ3: Can social debt be addressed and mitigated? The results, in this paper, stem from a longitudinal, real-life industrial case study and were confirmed using industrial focus groups. More specifically, to confirm the validity of the architec- tural social debt community smells and their measurement framework reported in this paper, the connected notions were stressed in two industry–academy mixed focus groups as part of a Dagstuhl Seminar on Technical Debt.1 The focus groups counted a total of nine senior members from several top industrial players, including Google, CAST Software, HP Inc., and VNomic. As part of the results of the focus groups, the validity of the architectural social debt community smells reported in this paper along with the DAHLIA framework to manage them was confirmed. Furthermore, the involved prac- titioners allowed a deeper exploration of previously unknown dimensions over the social debt phenomenon. For example, the definition and ramifications of social debt as a metaphor were refined with an even deeper relation to technical debt—a form of sociotechnical debt, wherefore the social causes always lead to nasty technical phenomena as well (e.g., code churn, unwanted changes, replicated code, and more). This latter form of sociotechnical debt reflects additional project cost which is caused by suboptimal sociotechnical decisions but manifests as negative and invisible characteristics in source code or connected software artifacts (e.g., requirements, software architecture, documentation, and so on) rather than delays or communication friction across the organizational structure.